// Code generated by xgen. DO NOT EDIT.

package stationxml

import (
	"encoding/xml"
)

// FDSNStationXML ...
type FDSNStationXML *RootType

// RootType is Date that this document was generated.
type RootType struct {
	SchemaVersionAttr float64        `xml:"schemaVersion,attr"`
	Source            string         `xml:"Source"`
	Sender            string         `xml:"Sender"`
	Module            string         `xml:"Module"`
	ModuleURI         string         `xml:"ModuleURI"`
	Created           string         `xml:"Created"`
	Network           []*NetworkType `xml:"Network"`
}

// NetworkType is This element is likely to be removed.
type NetworkType struct {
	Operator               []*OperatorType `xml:"Operator"`
	TotalNumberStations    *CounterType    `xml:"TotalNumberStations"`
	SelectedNumberStations *CounterType    `xml:"SelectedNumberStations"`
	Station                []*StationType  `xml:"Station"`
	*BaseNodeType
}

// StationType is URI of any type of external report
type StationType struct {
	Latitude               *LatitudeType            `xml:"Latitude"`
	Longitude              *LongitudeType           `xml:"Longitude"`
	Elevation              *DistanceType            `xml:"Elevation"`
	Site                   *SiteType                `xml:"Site"`
	WaterLevel             *FloatType               `xml:"WaterLevel"`
	Vault                  string                   `xml:"Vault"`
	Geology                string                   `xml:"Geology"`
	Equipment              []*EquipmentType         `xml:"Equipment"`
	Operator               []*OperatorType          `xml:"Operator"`
	CreationDate           string                   `xml:"CreationDate"`
	TerminationDate        string                   `xml:"TerminationDate"`
	TotalNumberChannels    *CounterType             `xml:"TotalNumberChannels"`
	SelectedNumberChannels *CounterType             `xml:"SelectedNumberChannels"`
	ExternalReference      []*ExternalReferenceType `xml:"ExternalReference"`
	Channel                []*ChannelType           `xml:"Channel"`
	*BaseNodeType
}

// ClockDrift ...
type ClockDrift struct {
	UnitAttr string `xml:"unit,attr,omitempty"`
}

// ChannelType is Elevation of the water surface in meters for underwater sites, where 0 is mean sea level.
// If you put an OBS on a lake bottom, where the lake surface is at elevation=1200 meters,
// then you should set WaterLevel=1200. An OBS in the ocean would
//                 have WaterLevel=0.
type ChannelType struct {
	LocationCodeAttr   string `xml:"locationCode,attr"`
	FsxSampleRateGroup *SampleRateGroup
	ExternalReference  []*ExternalReferenceType `xml:"ExternalReference"`
	Latitude           *LatitudeType            `xml:"Latitude"`
	Longitude          *LongitudeType           `xml:"Longitude"`
	Elevation          *DistanceType            `xml:"Elevation"`
	Depth              *DistanceType            `xml:"Depth"`
	Azimuth            *AzimuthType             `xml:"Azimuth"`
	Dip                *DipType                 `xml:"Dip"`
	WaterLevel         *FloatType               `xml:"WaterLevel"`
	Type               []string                 `xml:"Type"`
	ClockDrift         *ClockDrift              `xml:"ClockDrift"`
	CalibrationUnits   *UnitsType               `xml:"CalibrationUnits"`
	Sensor             *EquipmentType           `xml:"Sensor"`
	PreAmplifier       *EquipmentType           `xml:"PreAmplifier"`
	DataLogger         *EquipmentType           `xml:"DataLogger"`
	Equipment          []*EquipmentType         `xml:"Equipment"`
	Response           *ResponseType            `xml:"Response"`
	*BaseNodeType
}

// GainType ...
type GainType struct {
	Value     float64 `xml:"Value"`
	Frequency float64 `xml:"Frequency"`
}

// Type is The lowest frequency for which the InstrumentSensitivity is valid.
//             <FrequencyStart>, <FrequencyEnd> and <FrequencyDBVariation> are not
//             required, however, if one of these is present, then all must be present.
type Type []*FloatType

// FrequencyRangeGroup ...
type FrequencyRangeGroup struct {
	FrequencyStart       float64
	FrequencyEnd         float64
	FrequencyDBVariation float64
}

// SensitivityType is The frequency range for which the sensitivity value is
// valid within the dB variation specified.
type SensitivityType struct {
	FsxFrequencyRangeGroup *FrequencyRangeGroup
	InputUnits             *UnitsType `xml:"InputUnits"`
	OutputUnits            *UnitsType `xml:"OutputUnits"`
	*GainType
}

// EquipmentType is Date this equipment was calibrated
type EquipmentType struct {
	ResourceIdAttr   string   `xml:"resourceId,attr,omitempty"`
	Type             string   `xml:"Type"`
	Description      string   `xml:"Description"`
	Manufacturer     string   `xml:"Manufacturer"`
	Vendor           string   `xml:"Vendor"`
	Model            string   `xml:"Model"`
	SerialNumber     string   `xml:"SerialNumber"`
	InstallationDate string   `xml:"InstallationDate"`
	RemovalDate      string   `xml:"RemovalDate"`
	CalibrationDate  []string `xml:"CalibrationDate"`
}

// ResponseStageType is When a response is given in terms of a polynomial expansion of
// powers of the sensor output signal (e.g., Volts), a Polynomial stage is
// required to specify the Maclaurin coefficients of the expansion.
//
// In addition, an InstrumentPolynomial element must be present at Response level
// to represent the whole acquisition process, which contains the same Maclaurin
// coefficients, but scaled by powers of the overall gain for all stages.
type ResponseStageType struct {
	NumberAttr     *CounterType      `xml:"number,attr"`
	ResourceIdAttr string            `xml:"resourceId,attr,omitempty"`
	PolesZeros     *PolesZerosType   `xml:"PolesZeros"`
	Coefficients   *CoefficientsType `xml:"Coefficients"`
	ResponseList   *ResponseListType `xml:"ResponseList"`
	FIR            *FIRType          `xml:"FIR"`
	Decimation     *DecimationType   `xml:"Decimation"`
	StageGain      *GainType         `xml:"StageGain"`
	Polynomial     *PolynomialType   `xml:"Polynomial"`
}

// CommentType is Author of Comment.
type CommentType struct {
	IdAttr             *CounterType  `xml:"id,attr,omitempty"`
	SubjectAttr        string        `xml:"subject,attr,omitempty"`
	Value              string        `xml:"Value"`
	BeginEffectiveTime string        `xml:"BeginEffectiveTime"`
	EndEffectiveTime   string        `xml:"EndEffectiveTime"`
	Author             []*PersonType `xml:"Author"`
}

// PolesZerosType ...
type PolesZerosType struct {
	PzTransferFunctionType string          `xml:"PzTransferFunctionType"`
	NormalizationFactor    float64         `xml:"NormalizationFactor"`
	NormalizationFrequency *FrequencyType  `xml:"NormalizationFrequency"`
	Zero                   []*PoleZeroType `xml:"Zero"`
	Pole                   []*PoleZeroType `xml:"Pole"`
	*BaseFilterType
}

// NumeratorCoefficient ...
type NumeratorCoefficient struct {
	IAttr int     `xml:"i,attr,omitempty"`
	Value float64 `xml:",chardata"`
}

// FIRType ...
type FIRType struct {
	Symmetry             string                  `xml:"Symmetry"`
	NumeratorCoefficient []*NumeratorCoefficient `xml:"NumeratorCoefficient"`
	*BaseFilterType
}

// Numerator ...
type Numerator struct {
	NumberAttr *CounterType `xml:"number,attr,omitempty"`
	*FloatNoUnitType
}

// Denominator ...
type Denominator struct {
	NumberAttr *CounterType `xml:"number,attr,omitempty"`
	*FloatNoUnitType
}

// CoefficientsType ...
type CoefficientsType struct {
	CfTransferFunctionType string         `xml:"CfTransferFunctionType"`
	Numerator              []*Numerator   `xml:"Numerator"`
	Denominator            []*Denominator `xml:"Denominator"`
	*BaseFilterType
}

// ResponseListElementType ...
type ResponseListElementType struct {
	Frequency *FrequencyType `xml:"Frequency"`
	Amplitude *FloatType     `xml:"Amplitude"`
	Phase     *AngleType     `xml:"Phase"`
}

// ResponseListType ...
type ResponseListType struct {
	ResponseListElement []*ResponseListElementType `xml:"ResponseListElement"`
	*BaseFilterType
}

// Coefficient ...
type Coefficient struct {
	NumberAttr *CounterType `xml:"number,attr,omitempty"`
	*FloatNoUnitType
}

// PolynomialType ...
type PolynomialType struct {
	ApproximationType       string         `xml:"ApproximationType"`
	FrequencyLowerBound     *FrequencyType `xml:"FrequencyLowerBound"`
	FrequencyUpperBound     *FrequencyType `xml:"FrequencyUpperBound"`
	ApproximationLowerBound float64        `xml:"ApproximationLowerBound"`
	ApproximationUpperBound float64        `xml:"ApproximationUpperBound"`
	MaximumError            float64        `xml:"MaximumError"`
	Coefficient             []*Coefficient `xml:"Coefficient"`
	*BaseFilterType
}

// DecimationType ...
type DecimationType struct {
	InputSampleRate *FrequencyType `xml:"InputSampleRate"`
	Factor          int            `xml:"Factor"`
	Offset          int            `xml:"Offset"`
	Delay           *FloatType     `xml:"Delay"`
	Correction      *FloatType     `xml:"Correction"`
}

// UncertaintyDouble is 0.1
type UncertaintyDouble struct {
	XMLName               xml.Name `xml:"uncertaintyDouble"`
	PlusErrorAttr         float64  `xml:"plusError,attr,omitempty"`
	MinusErrorAttr        float64  `xml:"minusError,attr,omitempty"`
	MeasurementMethodAttr string   `xml:"measurementMethod,attr,omitempty"`
}

// FloatNoUnitType ...
type FloatNoUnitType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	Value                float64 `xml:",chardata"`
}

// FloatType ...
type FloatType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string  `xml:"unit,attr,omitempty"`
	Value                float64 `xml:",chardata"`
}

// SecondType ...
type SecondType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// VoltageType ...
type VoltageType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// AngleType ...
type AngleType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// LatitudeBaseType ...
type LatitudeBaseType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// LatitudeType ...
type LatitudeType struct {
	DatumAttr string `xml:"datum,attr,omitempty"`
	*LatitudeBaseType
}

// LongitudeBaseType ...
type LongitudeBaseType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// LongitudeType ...
type LongitudeType struct {
	DatumAttr string `xml:"datum,attr,omitempty"`
	*LongitudeBaseType
}

// AzimuthType ...
type AzimuthType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// DipType ...
type DipType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// DistanceType ...
type DistanceType struct {
	FsxUncertaintyDouble *UncertaintyDouble
	UnitAttr             string `xml:"unit,attr,omitempty"`
}

// FrequencyType ...
type FrequencyType struct {
	UnitAttr string `xml:"unit,attr,omitempty"`
}

// ApproximationType is 40.0
type ApproximationType *FloatType

// CfTransferFunctionType is 86400
type CfTransferFunctionType string

// SampleRateGroup ...
type SampleRateGroup struct {
	SampleRate      *SampleRateType
	SampleRateRatio *SampleRateRatioType
}

// SampleRateType ...
type SampleRateType struct {
	UnitAttr string `xml:"unit,attr,omitempty"`
}

// SampleRateRatioType ...
type SampleRateRatioType struct {
	NumberSamples int `xml:"NumberSamples"`
	NumberSeconds int `xml:"NumberSeconds"`
}

// PoleZeroType ...
type PoleZeroType struct {
	NumberAttr int              `xml:"number,attr,omitempty"`
	Real       *FloatNoUnitType `xml:"Real"`
	Imaginary  *FloatNoUnitType `xml:"Imaginary"`
}

// OperatorType ...
type OperatorType struct {
	Agency  string        `xml:"Agency"`
	Contact []*PersonType `xml:"Contact"`
	WebSite string        `xml:"WebSite"`
}

// PersonType ...
type PersonType struct {
	Name   []string           `xml:"Name"`
	Agency []string           `xml:"Agency"`
	Email  []*EmailType       `xml:"Email"`
	Phone  []*PhoneNumberType `xml:"Phone"`
}

// SiteType ...
type SiteType struct {
	Name        string `xml:"Name"`
	Description string `xml:"Description"`
	Town        string `xml:"Town"`
	County      string `xml:"County"`
	Region      string `xml:"Region"`
	Country     string `xml:"Country"`
}

// ExternalReferenceType ...
type ExternalReferenceType struct {
	URI         string `xml:"URI"`
	Description string `xml:"Description"`
}

// PhoneNumberType ...
type PhoneNumberType struct {
	DescriptionAttr string `xml:"description,attr,omitempty"`
	CountryCode     int    `xml:"CountryCode"`
	AreaCode        int    `xml:"AreaCode"`
	PhoneNumber     string `xml:"PhoneNumber"`
}

// UnitsType ...
type UnitsType struct {
	Name        string `xml:"Name"`
	Description string `xml:"Description"`
}

// IdentifierType ...
type IdentifierType struct {
	TypeAttr string `xml:"type,attr,omitempty"`
	Value    string `xml:",chardata"`
}

// BaseFilterType ...
type BaseFilterType struct {
	ResourceIdAttr string     `xml:"resourceId,attr,omitempty"`
	NameAttr       string     `xml:"name,attr,omitempty"`
	Description    string     `xml:"Description"`
	InputUnits     *UnitsType `xml:"InputUnits"`
	OutputUnits    *UnitsType `xml:"OutputUnits"`
}

// ResponseType ...
type ResponseType struct {
	ResourceIdAttr        string               `xml:"resourceId,attr,omitempty"`
	InstrumentSensitivity *SensitivityType     `xml:"InstrumentSensitivity"`
	InstrumentPolynomial  *PolynomialType      `xml:"InstrumentPolynomial"`
	Stage                 []*ResponseStageType `xml:"Stage"`
}

// BaseNodeType ...
type BaseNodeType struct {
	CodeAttr             string                `xml:"code,attr"`
	StartDateAttr        string                `xml:"startDate,attr,omitempty"`
	EndDateAttr          string                `xml:"endDate,attr,omitempty"`
	SourceIDAttr         string                `xml:"sourceID,attr,omitempty"`
	RestrictedStatusAttr *RestrictedStatusType `xml:"restrictedStatus,attr,omitempty"`
	AlternateCodeAttr    string                `xml:"alternateCode,attr,omitempty"`
	HistoricalCodeAttr   string                `xml:"historicalCode,attr,omitempty"`
	Description          string                `xml:"Description"`
	Identifier           []*IdentifierType     `xml:"Identifier"`
	Comment              []*CommentType        `xml:"Comment"`
	DataAvailability     *DataAvailabilityType `xml:"DataAvailability"`
}

// DataAvailabilityExtentType ...
type DataAvailabilityExtentType struct {
	StartAttr string `xml:"start,attr"`
	EndAttr   string `xml:"end,attr"`
}

// DataAvailabilitySpanType ...
type DataAvailabilitySpanType struct {
	StartAttr           string  `xml:"start,attr"`
	EndAttr             string  `xml:"end,attr"`
	NumberSegmentsAttr  int     `xml:"numberSegments,attr"`
	MaximumTimeTearAttr float64 `xml:"maximumTimeTear,attr,omitempty"`
}

// DataAvailabilityType ...
type DataAvailabilityType struct {
	Extent *DataAvailabilityExtentType `xml:"Extent"`
	Span   []*DataAvailabilitySpanType `xml:"Span"`
}
