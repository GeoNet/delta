// Code generated by main. DO NOT EDIT.

package stationxml

import (
	"bytes"
	"encoding/xml"
	"time"
)

type AngleType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// May be one of MACLAURIN
type ApproximationType string

// Azimuth of the component in degrees clockwise from geographic (true) north.
type AzimuthType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// The BaseFilterType is derived by all filters.
type BaseFilterType struct {
	Items       []string  `xml:",any"`
	Description string    `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	InputUnits  UnitsType `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits UnitsType `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	ResourceId  string    `xml:"resourceId,attr,omitempty"`
	Name        string    `xml:"name,attr,omitempty"`
}

// A base node type use in Network, Station, and Channel types.
type BaseNodeType struct {
	Items            []string             `xml:",any"`
	Description      string               `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	Identifier       []IdentifierType     `xml:"http://www.fdsn.org/xml/station/1 Identifier,omitempty"`
	Comment          []CommentType        `xml:"http://www.fdsn.org/xml/station/1 Comment,omitempty"`
	DataAvailability DataAvailabilityType `xml:"http://www.fdsn.org/xml/station/1 DataAvailability,omitempty"`
	Code             string               `xml:"code,attr"`
	StartDate        time.Time            `xml:"startDate,attr,omitempty"`
	EndDate          time.Time            `xml:"endDate,attr,omitempty"`
	SourceID         string               `xml:"sourceID,attr,omitempty"`
	RestrictedStatus RestrictedStatusType `xml:"restrictedStatus,attr,omitempty"`
	AlternateCode    string               `xml:"alternateCode,attr,omitempty"`
	HistoricalCode   string               `xml:"historicalCode,attr,omitempty"`
}

func (t *BaseNodeType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T BaseNodeType
	var layout struct {
		*T
		StartDate *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate   *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.StartDate = (*xsdDateTime)(&layout.T.StartDate)
	layout.EndDate = (*xsdDateTime)(&layout.T.EndDate)
	return e.EncodeElement(layout, start)
}
func (t *BaseNodeType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T BaseNodeType
	var overlay struct {
		*T
		StartDate *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate   *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.StartDate = (*xsdDateTime)(&overlay.T.StartDate)
	overlay.EndDate = (*xsdDateTime)(&overlay.T.EndDate)
	return d.DecodeElement(&overlay, &start)
}

// May be one of ANALOG (RADIANS/SECOND), ANALOG (HERTZ), DIGITAL
type CfTransferFunctionType string

// The Channel container.
// A Description element may be included with other information.
// An Identifier element may be included to designate a persistent identifier (e.g. DOI) to use for citation or reference.
// A Comment element may be included for arbitrary comments.
//
// An active Channel should not use the endDate attribute.
// Unlike SEED, do not use an endDate in the distant future to mean active.
type ChannelType struct {
	Items             []string                `xml:",any"`
	Description       string                  `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	Identifier        []IdentifierType        `xml:"http://www.fdsn.org/xml/station/1 Identifier,omitempty"`
	Comment           []CommentType           `xml:"http://www.fdsn.org/xml/station/1 Comment,omitempty"`
	DataAvailability  DataAvailabilityType    `xml:"http://www.fdsn.org/xml/station/1 DataAvailability,omitempty"`
	ExternalReference []ExternalReferenceType `xml:"http://www.fdsn.org/xml/station/1 ExternalReference,omitempty"`
	Latitude          LatitudeType            `xml:"http://www.fdsn.org/xml/station/1 Latitude"`
	Longitude         LongitudeType           `xml:"http://www.fdsn.org/xml/station/1 Longitude"`
	Elevation         DistanceType            `xml:"http://www.fdsn.org/xml/station/1 Elevation"`
	Depth             DistanceType            `xml:"http://www.fdsn.org/xml/station/1 Depth"`
	Azimuth           AzimuthType             `xml:"http://www.fdsn.org/xml/station/1 Azimuth,omitempty"`
	Dip               DipType                 `xml:"http://www.fdsn.org/xml/station/1 Dip,omitempty"`
	WaterLevel        FloatType               `xml:"http://www.fdsn.org/xml/station/1 WaterLevel,omitempty"`
	Type              []Type                  `xml:"http://www.fdsn.org/xml/station/1 Type,omitempty"`
	SampleRate        SampleRateType          `xml:"http://www.fdsn.org/xml/station/1 SampleRate"`
	SampleRateRatio   SampleRateRatioType     `xml:"http://www.fdsn.org/xml/station/1 SampleRateRatio,omitempty"`
	ClockDrift        ClockDrift              `xml:"http://www.fdsn.org/xml/station/1 ClockDrift,omitempty"`
	CalibrationUnits  UnitsType               `xml:"http://www.fdsn.org/xml/station/1 CalibrationUnits,omitempty"`
	Sensor            EquipmentType           `xml:"http://www.fdsn.org/xml/station/1 Sensor,omitempty"`
	PreAmplifier      EquipmentType           `xml:"http://www.fdsn.org/xml/station/1 PreAmplifier,omitempty"`
	DataLogger        EquipmentType           `xml:"http://www.fdsn.org/xml/station/1 DataLogger,omitempty"`
	Equipment         []EquipmentType         `xml:"http://www.fdsn.org/xml/station/1 Equipment,omitempty"`
	Response          ResponseType            `xml:"http://www.fdsn.org/xml/station/1 Response,omitempty"`
	LocationCode      string                  `xml:"locationCode,attr"`
	Code              string                  `xml:"code,attr"`
	StartDate         time.Time               `xml:"startDate,attr,omitempty"`
	EndDate           time.Time               `xml:"endDate,attr,omitempty"`
	SourceID          string                  `xml:"sourceID,attr,omitempty"`
	RestrictedStatus  RestrictedStatusType    `xml:"restrictedStatus,attr,omitempty"`
	AlternateCode     string                  `xml:"alternateCode,attr,omitempty"`
	HistoricalCode    string                  `xml:"historicalCode,attr,omitempty"`
}

func (t *ChannelType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T ChannelType
	var layout struct {
		*T
		StartDate *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate   *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.StartDate = (*xsdDateTime)(&layout.T.StartDate)
	layout.EndDate = (*xsdDateTime)(&layout.T.EndDate)
	return e.EncodeElement(layout, start)
}
func (t *ChannelType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ChannelType
	var overlay struct {
		*T
		StartDate *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate   *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.StartDate = (*xsdDateTime)(&overlay.T.StartDate)
	overlay.EndDate = (*xsdDateTime)(&overlay.T.EndDate)
	return d.DecodeElement(&overlay, &start)
}

type ClockDrift struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

type Coefficient struct {
	Value             float64 `xml:",chardata"`
	Number            int     `xml:"number,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Response type for filter giving coefficients. Laplace transforms or analog
// filters can both be expressed using this type as well but the PolesZeros should be used
// instead. Digital filters with no denominator should use FIR instead.
type CoefficientsType struct {
	Items                  []string               `xml:",any"`
	Description            string                 `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	InputUnits             UnitsType              `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits            UnitsType              `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	CfTransferFunctionType CfTransferFunctionType `xml:"http://www.fdsn.org/xml/station/1 CfTransferFunctionType"`
	Numerator              []Numerator            `xml:"http://www.fdsn.org/xml/station/1 Numerator,omitempty"`
	Denominator            []Denominator          `xml:"http://www.fdsn.org/xml/station/1 Denominator,omitempty"`
	ResourceId             string                 `xml:"resourceId,attr,omitempty"`
	Name                   string                 `xml:"name,attr,omitempty"`
}

// Container for a comment or log entry.
type CommentType struct {
	Value              string       `xml:"http://www.fdsn.org/xml/station/1 Value"`
	BeginEffectiveTime time.Time    `xml:"http://www.fdsn.org/xml/station/1 BeginEffectiveTime,omitempty"`
	EndEffectiveTime   time.Time    `xml:"http://www.fdsn.org/xml/station/1 EndEffectiveTime,omitempty"`
	Author             []PersonType `xml:"http://www.fdsn.org/xml/station/1 Author,omitempty"`
	Id                 int          `xml:"id,attr,omitempty"`
	Subject            string       `xml:"subject,attr,omitempty"`
}

func (t *CommentType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T CommentType
	var layout struct {
		*T
		BeginEffectiveTime *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 BeginEffectiveTime,omitempty"`
		EndEffectiveTime   *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 EndEffectiveTime,omitempty"`
	}
	layout.T = (*T)(t)
	layout.BeginEffectiveTime = (*xsdDateTime)(&layout.T.BeginEffectiveTime)
	layout.EndEffectiveTime = (*xsdDateTime)(&layout.T.EndEffectiveTime)
	return e.EncodeElement(layout, start)
}
func (t *CommentType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T CommentType
	var overlay struct {
		*T
		BeginEffectiveTime *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 BeginEffectiveTime,omitempty"`
		EndEffectiveTime   *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 EndEffectiveTime,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.BeginEffectiveTime = (*xsdDateTime)(&overlay.T.BeginEffectiveTime)
	overlay.EndEffectiveTime = (*xsdDateTime)(&overlay.T.EndEffectiveTime)
	return d.DecodeElement(&overlay, &start)
}

// Data availability extents, the earliest and
// latest data available. No information about the continuity of the data
// is included or implied.
type DataAvailabilityExtentType struct {
	Start time.Time `xml:"start,attr"`
	End   time.Time `xml:"end,attr"`
}

func (t *DataAvailabilityExtentType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T DataAvailabilityExtentType
	var layout struct {
		*T
		Start *xsdDateTime `xml:"start,attr"`
		End   *xsdDateTime `xml:"end,attr"`
	}
	layout.T = (*T)(t)
	layout.Start = (*xsdDateTime)(&layout.T.Start)
	layout.End = (*xsdDateTime)(&layout.T.End)
	return e.EncodeElement(layout, start)
}
func (t *DataAvailabilityExtentType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DataAvailabilityExtentType
	var overlay struct {
		*T
		Start *xsdDateTime `xml:"start,attr"`
		End   *xsdDateTime `xml:"end,attr"`
	}
	overlay.T = (*T)(t)
	overlay.Start = (*xsdDateTime)(&overlay.T.Start)
	overlay.End = (*xsdDateTime)(&overlay.T.End)
	return d.DecodeElement(&overlay, &start)
}

// A type for describing data availability spans, with variable
// continuity. The time range described may be based on the request parameters that
// generated the document and not necessarily relate to continuity outside of the
// range. It may also be a smaller time window than the request depending on the data
// characteristics.
type DataAvailabilitySpanType struct {
	Start           time.Time `xml:"start,attr"`
	End             time.Time `xml:"end,attr"`
	NumberSegments  int       `xml:"numberSegments,attr"`
	MaximumTimeTear float64   `xml:"maximumTimeTear,attr,omitempty"`
}

func (t *DataAvailabilitySpanType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T DataAvailabilitySpanType
	var layout struct {
		*T
		Start *xsdDateTime `xml:"start,attr"`
		End   *xsdDateTime `xml:"end,attr"`
	}
	layout.T = (*T)(t)
	layout.Start = (*xsdDateTime)(&layout.T.Start)
	layout.End = (*xsdDateTime)(&layout.T.End)
	return e.EncodeElement(layout, start)
}
func (t *DataAvailabilitySpanType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DataAvailabilitySpanType
	var overlay struct {
		*T
		Start *xsdDateTime `xml:"start,attr"`
		End   *xsdDateTime `xml:"end,attr"`
	}
	overlay.T = (*T)(t)
	overlay.Start = (*xsdDateTime)(&overlay.T.Start)
	overlay.End = (*xsdDateTime)(&overlay.T.End)
	return d.DecodeElement(&overlay, &start)
}

// A type for describing data availability.
type DataAvailabilityType struct {
	Items  []string                   `xml:",any"`
	Extent DataAvailabilityExtentType `xml:"http://www.fdsn.org/xml/station/1 Extent,omitempty"`
	Span   []DataAvailabilitySpanType `xml:"http://www.fdsn.org/xml/station/1 Span,omitempty"`
}

// Representation of decimation stage
type DecimationType struct {
	InputSampleRate FrequencyType `xml:"http://www.fdsn.org/xml/station/1 InputSampleRate"`
	Factor          int           `xml:"http://www.fdsn.org/xml/station/1 Factor"`
	Offset          int           `xml:"http://www.fdsn.org/xml/station/1 Offset"`
	Delay           FloatType     `xml:"http://www.fdsn.org/xml/station/1 Delay"`
	Correction      FloatType     `xml:"http://www.fdsn.org/xml/station/1 Correction"`
}

type Denominator struct {
	Value             float64 `xml:",chardata"`
	Number            int     `xml:"number,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Dip of the component in degrees, positive is down from horizontal.
// For horizontal dip=0, for vertical upwards
// dip=-90 and for vertical downwards dip=+90.
type DipType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

type DistanceType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Must match the pattern [\w\.\-_]+@[\w\.\-_]+
type EmailType string

// A type for equipment related to data acquisition or processing.
type EquipmentType struct {
	Items            []string    `xml:",any"`
	Type             string      `xml:"http://www.fdsn.org/xml/station/1 Type,omitempty"`
	Description      string      `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	Manufacturer     string      `xml:"http://www.fdsn.org/xml/station/1 Manufacturer,omitempty"`
	Vendor           string      `xml:"http://www.fdsn.org/xml/station/1 Vendor,omitempty"`
	Model            string      `xml:"http://www.fdsn.org/xml/station/1 Model,omitempty"`
	SerialNumber     string      `xml:"http://www.fdsn.org/xml/station/1 SerialNumber,omitempty"`
	InstallationDate time.Time   `xml:"http://www.fdsn.org/xml/station/1 InstallationDate,omitempty"`
	RemovalDate      time.Time   `xml:"http://www.fdsn.org/xml/station/1 RemovalDate,omitempty"`
	CalibrationDate  []time.Time `xml:"http://www.fdsn.org/xml/station/1 CalibrationDate,omitempty"`
	ResourceId       string      `xml:"resourceId,attr,omitempty"`
}

func (t *EquipmentType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T EquipmentType
	var layout struct {
		*T
		InstallationDate *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 InstallationDate,omitempty"`
		RemovalDate      *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 RemovalDate,omitempty"`
		CalibrationDate  *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 CalibrationDate,omitempty"`
	}
	layout.T = (*T)(t)
	layout.InstallationDate = (*xsdDateTime)(&layout.T.InstallationDate)
	layout.RemovalDate = (*xsdDateTime)(&layout.T.RemovalDate)
	layout.CalibrationDate = (*xsdDateTime)(&layout.T.CalibrationDate)
	return e.EncodeElement(layout, start)
}
func (t *EquipmentType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T EquipmentType
	var overlay struct {
		*T
		InstallationDate *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 InstallationDate,omitempty"`
		RemovalDate      *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 RemovalDate,omitempty"`
		CalibrationDate  *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 CalibrationDate,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.InstallationDate = (*xsdDateTime)(&overlay.T.InstallationDate)
	overlay.RemovalDate = (*xsdDateTime)(&overlay.T.RemovalDate)
	overlay.CalibrationDate = (*xsdDateTime)(&overlay.T.CalibrationDate)
	return d.DecodeElement(&overlay, &start)
}

// This type contains a Uniform Resource Identifier (URI) and description
// for external information that users may want to reference.
type ExternalReferenceType struct {
	URI         string `xml:"http://www.fdsn.org/xml/station/1 URI"`
	Description string `xml:"http://www.fdsn.org/xml/station/1 Description"`
}

// Response type for FIR filter.  FIR filters
// are also commonly documented using a digital Coefficients element with no
// denominators, but it is preferred to use this type
// allowing representation of symmetric FIR coefficients without repeating them.
type FIRType struct {
	Items                []string               `xml:",any"`
	Description          string                 `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	InputUnits           UnitsType              `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits          UnitsType              `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	Symmetry             Symmetry               `xml:"http://www.fdsn.org/xml/station/1 Symmetry"`
	NumeratorCoefficient []NumeratorCoefficient `xml:"http://www.fdsn.org/xml/station/1 NumeratorCoefficient,omitempty"`
	ResourceId           string                 `xml:"resourceId,attr,omitempty"`
	Name                 string                 `xml:"name,attr,omitempty"`
}

// Representation of floating-point numbers without unit.
type FloatNoUnitType struct {
	Value             float64 `xml:",chardata"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

type FloatType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

type FrequencyType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Type used for representing sensitivity at a given frequency. This complex type
// can be used to represent both total sensitivities and individual stage gains.
type GainType struct {
	Value     float64 `xml:"http://www.fdsn.org/xml/station/1 Value"`
	Frequency float64 `xml:"http://www.fdsn.org/xml/station/1 Frequency"`
}

// A type to document persistent identifiers.
// Identifier values should be specified without a URI scheme (prefix),
// instead the identifier type is documented as an attribute.
type IdentifierType struct {
	Value string `xml:",chardata"`
	Type  string `xml:"type,attr,omitempty"`
}

// Base latitude type.
type LatitudeBaseType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Latitude type extending the base type to add datum as an attribute with default.
type LatitudeType struct {
	Value             float64 `xml:",chardata"`
	Datum             string  `xml:"datum,attr,omitempty"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

func (t *LatitudeType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T LatitudeType
	var overlay struct {
		*T
		Datum *string `xml:"datum,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Datum = (*string)(&overlay.T.Datum)
	return d.DecodeElement(&overlay, &start)
}

// Base longitude type.
type LongitudeBaseType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Longitude type extending the base type to add datum as an attribute with default.
type LongitudeType struct {
	Value             float64 `xml:",chardata"`
	Datum             string  `xml:"datum,attr,omitempty"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

func (t *LongitudeType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T LongitudeType
	var overlay struct {
		*T
		Datum *string `xml:"datum,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Datum = (*string)(&overlay.T.Datum)
	return d.DecodeElement(&overlay, &start)
}

// The Network container. All station metadata for this network is contained within this element.
// A Description element may be included with the official network name and other descriptive information.
// An Identifier element may be included to designate a persistent identifier (e.g. DOI) to use for citation.
// A Comment element may be included for additional comments.
//
// An active Network should not use the endDate attribute.
// Unlike SEED, do not use an endDate in the distant future to mean active.
type NetworkType struct {
	Items                  []string             `xml:",any"`
	Description            string               `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	Identifier             []IdentifierType     `xml:"http://www.fdsn.org/xml/station/1 Identifier,omitempty"`
	Comment                []CommentType        `xml:"http://www.fdsn.org/xml/station/1 Comment,omitempty"`
	DataAvailability       DataAvailabilityType `xml:"http://www.fdsn.org/xml/station/1 DataAvailability,omitempty"`
	Operator               []OperatorType       `xml:"http://www.fdsn.org/xml/station/1 Operator,omitempty"`
	TotalNumberStations    int                  `xml:"http://www.fdsn.org/xml/station/1 TotalNumberStations,omitempty"`
	SelectedNumberStations int                  `xml:"http://www.fdsn.org/xml/station/1 SelectedNumberStations,omitempty"`
	Station                []StationType        `xml:"http://www.fdsn.org/xml/station/1 Station,omitempty"`
	Code                   string               `xml:"code,attr"`
	StartDate              time.Time            `xml:"startDate,attr,omitempty"`
	EndDate                time.Time            `xml:"endDate,attr,omitempty"`
	SourceID               string               `xml:"sourceID,attr,omitempty"`
	RestrictedStatus       RestrictedStatusType `xml:"restrictedStatus,attr,omitempty"`
	AlternateCode          string               `xml:"alternateCode,attr,omitempty"`
	HistoricalCode         string               `xml:"historicalCode,attr,omitempty"`
}

func (t *NetworkType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T NetworkType
	var layout struct {
		*T
		StartDate *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate   *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.StartDate = (*xsdDateTime)(&layout.T.StartDate)
	layout.EndDate = (*xsdDateTime)(&layout.T.EndDate)
	return e.EncodeElement(layout, start)
}
func (t *NetworkType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T NetworkType
	var overlay struct {
		*T
		StartDate *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate   *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.StartDate = (*xsdDateTime)(&overlay.T.StartDate)
	overlay.EndDate = (*xsdDateTime)(&overlay.T.EndDate)
	return d.DecodeElement(&overlay, &start)
}

// May be one of NOMINAL, CALCULATED
type NominalType string

type Numerator struct {
	Value             float64 `xml:",chardata"`
	Number            int     `xml:"number,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

type NumeratorCoefficient struct {
	Value float64 `xml:",chardata"`
	I     int     `xml:"i,attr,omitempty"`
}

// Since the Contact element is a generic type that represents any contact
// person, it also has its own optional Agency element.
// It is expected that typically the contact's optional Agency tag will match the Operator Agency.
// Only contacts appropriate for the enclosing element should be included in the Operator tag.
type OperatorType struct {
	Agency  string       `xml:"http://www.fdsn.org/xml/station/1 Agency"`
	Contact []PersonType `xml:"http://www.fdsn.org/xml/station/1 Contact,omitempty"`
	WebSite string       `xml:"http://www.fdsn.org/xml/station/1 WebSite,omitempty"`
}

// Person's contact information. A person can belong
// to multiple agencies and have multiple email addresses and phone numbers.
type PersonType struct {
	Name   []string          `xml:"http://www.fdsn.org/xml/station/1 Name,omitempty"`
	Agency []string          `xml:"http://www.fdsn.org/xml/station/1 Agency,omitempty"`
	Email  []EmailType       `xml:"http://www.fdsn.org/xml/station/1 Email,omitempty"`
	Phone  []PhoneNumberType `xml:"http://www.fdsn.org/xml/station/1 Phone,omitempty"`
}

// Must match the pattern [0-9]+-[0-9]+
type PhoneNumber string

type PhoneNumberType struct {
	CountryCode int         `xml:"http://www.fdsn.org/xml/station/1 CountryCode,omitempty"`
	AreaCode    int         `xml:"http://www.fdsn.org/xml/station/1 AreaCode"`
	PhoneNumber PhoneNumber `xml:"http://www.fdsn.org/xml/station/1 PhoneNumber"`
	Description string      `xml:"description,attr,omitempty"`
}

type PoleZeroType struct {
	Real      FloatNoUnitType `xml:"http://www.fdsn.org/xml/station/1 Real"`
	Imaginary FloatNoUnitType `xml:"http://www.fdsn.org/xml/station/1 Imaginary"`
	Number    int             `xml:"number,attr,omitempty"`
}

type PolesZerosType struct {
	Items                  []string               `xml:",any"`
	Description            string                 `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	InputUnits             UnitsType              `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits            UnitsType              `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	PzTransferFunctionType PzTransferFunctionType `xml:"http://www.fdsn.org/xml/station/1 PzTransferFunctionType"`
	NormalizationFactor    float64                `xml:"http://www.fdsn.org/xml/station/1 NormalizationFactor,omitempty"`
	NormalizationFrequency FrequencyType          `xml:"http://www.fdsn.org/xml/station/1 NormalizationFrequency"`
	Zero                   []PoleZeroType         `xml:"http://www.fdsn.org/xml/station/1 Zero,omitempty"`
	Pole                   []PoleZeroType         `xml:"http://www.fdsn.org/xml/station/1 Pole,omitempty"`
	ResourceId             string                 `xml:"resourceId,attr,omitempty"`
	Name                   string                 `xml:"name,attr,omitempty"`
}

func (t *PolesZerosType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T PolesZerosType
	var overlay struct {
		*T
		NormalizationFactor *float64 `xml:"http://www.fdsn.org/xml/station/1 NormalizationFactor,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.NormalizationFactor = (*float64)(&overlay.T.NormalizationFactor)
	return d.DecodeElement(&overlay, &start)
}

// Response type for a response represented as a polynomial expansion,
// which allows non-linear sensors to be described. Used at either a stage of
// acquisition response or a complete system.
type PolynomialType struct {
	Items                   []string          `xml:",any"`
	Description             string            `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	InputUnits              UnitsType         `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits             UnitsType         `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	ApproximationType       ApproximationType `xml:"http://www.fdsn.org/xml/station/1 ApproximationType,omitempty"`
	FrequencyLowerBound     FrequencyType     `xml:"http://www.fdsn.org/xml/station/1 FrequencyLowerBound"`
	FrequencyUpperBound     FrequencyType     `xml:"http://www.fdsn.org/xml/station/1 FrequencyUpperBound"`
	ApproximationLowerBound float64           `xml:"http://www.fdsn.org/xml/station/1 ApproximationLowerBound"`
	ApproximationUpperBound float64           `xml:"http://www.fdsn.org/xml/station/1 ApproximationUpperBound"`
	MaximumError            float64           `xml:"http://www.fdsn.org/xml/station/1 MaximumError"`
	Coefficient             []Coefficient     `xml:"http://www.fdsn.org/xml/station/1 Coefficient"`
	ResourceId              string            `xml:"resourceId,attr,omitempty"`
	Name                    string            `xml:"name,attr,omitempty"`
}

func (t *PolynomialType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T PolynomialType
	var overlay struct {
		*T
		ApproximationType *ApproximationType `xml:"http://www.fdsn.org/xml/station/1 ApproximationType,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.ApproximationType = (*ApproximationType)(&overlay.T.ApproximationType)
	return d.DecodeElement(&overlay, &start)
}

// May be one of LAPLACE (RADIANS/SECOND), LAPLACE (HERTZ), DIGITAL (Z-TRANSFORM)
type PzTransferFunctionType string

type ResponseListElementType struct {
	Frequency FrequencyType `xml:"http://www.fdsn.org/xml/station/1 Frequency"`
	Amplitude FloatType     `xml:"http://www.fdsn.org/xml/station/1 Amplitude"`
	Phase     AngleType     `xml:"http://www.fdsn.org/xml/station/1 Phase"`
}

// Response type for a list of frequency, amplitude, and phase values.
// Because it is less flexible, the other filter types, PolesZeros,
// Coefficients, FIR, etc, are preferred.
type ResponseListType struct {
	Items               []string                  `xml:",any"`
	Description         string                    `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	InputUnits          UnitsType                 `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits         UnitsType                 `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	ResponseListElement []ResponseListElementType `xml:"http://www.fdsn.org/xml/station/1 ResponseListElement,omitempty"`
	ResourceId          string                    `xml:"resourceId,attr,omitempty"`
	Name                string                    `xml:"name,attr,omitempty"`
}

// Type for channel response entry or stage.  A full response is
// represented as an ordered sequence of these stages.
//
// A filter, (PolesZeros, Coefficients, FIR, etc) is not required, but is
// recommended to provide a place to store the input and output units
// even in the case of "gain-only" stages.
//
// For an analog gain-only stage, use a PolesZeros filter with no poles
// or zeros, PzTransferFunctionType=LAPLACE (RADIANS/SECOND)",
// NormalizationFactor=1 and NormalizationFrequency=0.
//
// For a digital gain-only stage, use a FIR filter with one
// numerator with value 1.0, and symmetry=NONE. While a digital Coefficients
// filter can serve the same purpose and is common, the FIR filter is more concise.
type ResponseStageType struct {
	Items        []string         `xml:",any"`
	PolesZeros   PolesZerosType   `xml:"http://www.fdsn.org/xml/station/1 PolesZeros,omitempty"`
	Coefficients CoefficientsType `xml:"http://www.fdsn.org/xml/station/1 Coefficients,omitempty"`
	ResponseList ResponseListType `xml:"http://www.fdsn.org/xml/station/1 ResponseList,omitempty"`
	FIR          FIRType          `xml:"http://www.fdsn.org/xml/station/1 FIR,omitempty"`
	Decimation   DecimationType   `xml:"http://www.fdsn.org/xml/station/1 Decimation,omitempty"`
	StageGain    GainType         `xml:"http://www.fdsn.org/xml/station/1 StageGain,omitempty"`
	Polynomial   PolynomialType   `xml:"http://www.fdsn.org/xml/station/1 Polynomial,omitempty"`
	Number       int              `xml:"number,attr"`
	ResourceId   string           `xml:"resourceId,attr,omitempty"`
}

// The complete instrument response for this channel that expresses the effect of the
// geophysical instrumentation used to record the input ground motion.
// The information can be used to convert raw data to Earth unit measurement at a specified
// frequency or within a range of frequencies.
// It is strongly suggested that either InstrumentSensitivity or InstrumentPolynomial should be present.
//
// In cases where the response is unknown, for example really old channels,
// or where a response is not applicable, like textual log channels,
// it is preferred that an empty
// response element be used, <response></response>,
// to positively indicate that no response exists.
type ResponseType struct {
	Items                 []string            `xml:",any"`
	InstrumentSensitivity SensitivityType     `xml:"http://www.fdsn.org/xml/station/1 InstrumentSensitivity,omitempty"`
	InstrumentPolynomial  PolynomialType      `xml:"http://www.fdsn.org/xml/station/1 InstrumentPolynomial,omitempty"`
	Stage                 []ResponseStageType `xml:"http://www.fdsn.org/xml/station/1 Stage,omitempty"`
	ResourceId            string              `xml:"resourceId,attr,omitempty"`
}

// May be one of open, closed, partial
type RestrictedStatusType string

// Root-level for StationXML documents.
type RootType struct {
	Items         []string      `xml:",any"`
	Source        string        `xml:"http://www.fdsn.org/xml/station/1 Source"`
	Sender        string        `xml:"http://www.fdsn.org/xml/station/1 Sender,omitempty"`
	Module        string        `xml:"http://www.fdsn.org/xml/station/1 Module,omitempty"`
	ModuleURI     string        `xml:"http://www.fdsn.org/xml/station/1 ModuleURI,omitempty"`
	Created       time.Time     `xml:"http://www.fdsn.org/xml/station/1 Created"`
	Network       []NetworkType `xml:"http://www.fdsn.org/xml/station/1 Network"`
	SchemaVersion float64       `xml:"schemaVersion,attr"`
}

func (t *RootType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T RootType
	var layout struct {
		*T
		Created *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 Created"`
	}
	layout.T = (*T)(t)
	layout.Created = (*xsdDateTime)(&layout.T.Created)
	return e.EncodeElement(layout, start)
}
func (t *RootType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T RootType
	var overlay struct {
		*T
		Created *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 Created"`
	}
	overlay.T = (*T)(t)
	overlay.Created = (*xsdDateTime)(&overlay.T.Created)
	return d.DecodeElement(&overlay, &start)
}

type SampleRateRatioType struct {
	NumberSamples int `xml:"http://www.fdsn.org/xml/station/1 NumberSamples"`
	NumberSeconds int `xml:"http://www.fdsn.org/xml/station/1 NumberSeconds"`
}

type SampleRateType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// A time duration value in seconds.
type SecondType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

// Type for sensitivity, input/output units and relevant frequency range.
type SensitivityType struct {
	Value                float64   `xml:"http://www.fdsn.org/xml/station/1 Value"`
	Frequency            float64   `xml:"http://www.fdsn.org/xml/station/1 Frequency"`
	InputUnits           UnitsType `xml:"http://www.fdsn.org/xml/station/1 InputUnits"`
	OutputUnits          UnitsType `xml:"http://www.fdsn.org/xml/station/1 OutputUnits"`
	FrequencyStart       float64   `xml:"http://www.fdsn.org/xml/station/1 FrequencyStart"`
	FrequencyEnd         float64   `xml:"http://www.fdsn.org/xml/station/1 FrequencyEnd"`
	FrequencyDBVariation float64   `xml:"http://www.fdsn.org/xml/station/1 FrequencyDBVariation"`
}

// Description of a location using name and optional geopolitical boundaries (country, city, etc.).
type SiteType struct {
	Items       []string `xml:",any"`
	Name        string   `xml:"http://www.fdsn.org/xml/station/1 Name"`
	Description string   `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	Town        string   `xml:"http://www.fdsn.org/xml/station/1 Town,omitempty"`
	County      string   `xml:"http://www.fdsn.org/xml/station/1 County,omitempty"`
	Region      string   `xml:"http://www.fdsn.org/xml/station/1 Region,omitempty"`
	Country     string   `xml:"http://www.fdsn.org/xml/station/1 Country,omitempty"`
}

// The Station container. All channel metadata for this station is contained within this element.
// A Description element may be included with the official station name and other descriptive information.
// An Identifier element may be included to designate a persistent identifier (e.g. DOI) to use for citation or reference.
// A Comment element may be included for additional comments.
//
// An active Station should not use the endDate attribute.
// Unlike SEED, do not use an endDate in the distant future to mean active.
type StationType struct {
	Items                  []string                `xml:",any"`
	Description            string                  `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
	Identifier             []IdentifierType        `xml:"http://www.fdsn.org/xml/station/1 Identifier,omitempty"`
	Comment                []CommentType           `xml:"http://www.fdsn.org/xml/station/1 Comment,omitempty"`
	DataAvailability       DataAvailabilityType    `xml:"http://www.fdsn.org/xml/station/1 DataAvailability,omitempty"`
	Latitude               LatitudeType            `xml:"http://www.fdsn.org/xml/station/1 Latitude"`
	Longitude              LongitudeType           `xml:"http://www.fdsn.org/xml/station/1 Longitude"`
	Elevation              DistanceType            `xml:"http://www.fdsn.org/xml/station/1 Elevation"`
	Site                   SiteType                `xml:"http://www.fdsn.org/xml/station/1 Site"`
	WaterLevel             FloatType               `xml:"http://www.fdsn.org/xml/station/1 WaterLevel,omitempty"`
	Vault                  string                  `xml:"http://www.fdsn.org/xml/station/1 Vault,omitempty"`
	Geology                string                  `xml:"http://www.fdsn.org/xml/station/1 Geology,omitempty"`
	Equipment              []EquipmentType         `xml:"http://www.fdsn.org/xml/station/1 Equipment,omitempty"`
	Operator               []OperatorType          `xml:"http://www.fdsn.org/xml/station/1 Operator,omitempty"`
	CreationDate           time.Time               `xml:"http://www.fdsn.org/xml/station/1 CreationDate,omitempty"`
	TerminationDate        time.Time               `xml:"http://www.fdsn.org/xml/station/1 TerminationDate,omitempty"`
	TotalNumberChannels    int                     `xml:"http://www.fdsn.org/xml/station/1 TotalNumberChannels,omitempty"`
	SelectedNumberChannels int                     `xml:"http://www.fdsn.org/xml/station/1 SelectedNumberChannels,omitempty"`
	ExternalReference      []ExternalReferenceType `xml:"http://www.fdsn.org/xml/station/1 ExternalReference,omitempty"`
	Channel                []ChannelType           `xml:"http://www.fdsn.org/xml/station/1 Channel,omitempty"`
	Code                   string                  `xml:"code,attr"`
	StartDate              time.Time               `xml:"startDate,attr,omitempty"`
	EndDate                time.Time               `xml:"endDate,attr,omitempty"`
	SourceID               string                  `xml:"sourceID,attr,omitempty"`
	RestrictedStatus       RestrictedStatusType    `xml:"restrictedStatus,attr,omitempty"`
	AlternateCode          string                  `xml:"alternateCode,attr,omitempty"`
	HistoricalCode         string                  `xml:"historicalCode,attr,omitempty"`
}

func (t *StationType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T StationType
	var layout struct {
		*T
		CreationDate    *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 CreationDate,omitempty"`
		TerminationDate *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 TerminationDate,omitempty"`
		StartDate       *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate         *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.CreationDate = (*xsdDateTime)(&layout.T.CreationDate)
	layout.TerminationDate = (*xsdDateTime)(&layout.T.TerminationDate)
	layout.StartDate = (*xsdDateTime)(&layout.T.StartDate)
	layout.EndDate = (*xsdDateTime)(&layout.T.EndDate)
	return e.EncodeElement(layout, start)
}
func (t *StationType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T StationType
	var overlay struct {
		*T
		CreationDate    *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 CreationDate,omitempty"`
		TerminationDate *xsdDateTime `xml:"http://www.fdsn.org/xml/station/1 TerminationDate,omitempty"`
		StartDate       *xsdDateTime `xml:"startDate,attr,omitempty"`
		EndDate         *xsdDateTime `xml:"endDate,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.CreationDate = (*xsdDateTime)(&overlay.T.CreationDate)
	overlay.TerminationDate = (*xsdDateTime)(&overlay.T.TerminationDate)
	overlay.StartDate = (*xsdDateTime)(&overlay.T.StartDate)
	overlay.EndDate = (*xsdDateTime)(&overlay.T.EndDate)
	return d.DecodeElement(&overlay, &start)
}

// May be one of NONE, EVEN, ODD
type Symmetry string

// May be one of TRIGGERED, CONTINUOUS, HEALTH, GEOPHYSICAL, WEATHER, FLAG, SYNTHESIZED, INPUT, EXPERIMENTAL, MAINTENANCE, BEAM
type Type string

// A type to document units; use SI whenever possible.
type UnitsType struct {
	Name        string `xml:"http://www.fdsn.org/xml/station/1 Name"`
	Description string `xml:"http://www.fdsn.org/xml/station/1 Description,omitempty"`
}

type VoltageType struct {
	Value             float64 `xml:",chardata"`
	Unit              string  `xml:"unit,attr,omitempty"`
	PlusError         float64 `xml:"plusError,attr,omitempty"`
	MinusError        float64 `xml:"minusError,attr,omitempty"`
	MeasurementMethod string  `xml:"measurementMethod,attr,omitempty"`
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}
