package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"github.com/GeoNet/delta/helper/metadb"
	"github.com/GeoNet/delta/resp"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

const header = "<?xml version=\"1.0\" standalone=\"yes\"?>\n"
const warning = "<!-- warning this file is automatically generated -->\n"

var aliases = map[string]string{
	"LPOC": "3A",
}

var gps = map[string]string{
	"10417": "feruno", //# 3B-050008 @ AMBC
	"331":   "feruno", //# 3B-050057 @ CCCC
	"306":   "feruno", //# 3B-050048 @ CHHC
	"10402": "garmin", //# 3B-050019 @ CSTC
	"10409": "garmin", //# 3B-050038 @ CULC
	"10462": "garmin", //# 3A-040027 @ D03C
	"10461": "garmin", //# 3A-040007 @ D05C
	"10459": "garmin", //# 3A-040001 @ D06C
	"10444": "garmin", //# 3B-050010 @ D07C
	"10458": "garmin", //# 3B-050016 @ D08C
	"10453": "garmin", //# 3A-040023 @ D09C
	"10456": "garmin", //# 3A-040002 @ D10C
	"10405": "garmin", //# 3B-050013 @ DB1C
	"10449": "garmin", //# 3A-040009 @ DB2C
	"316":   "feruno", //# 3B-050006 @ DORC
	"227":   "feruno", //# 3A-040015 @ DSLC
	"311":   "feruno", //# 3B-050007 @ GDLC
	"206":   "feruno", //# 3A-040006 @ HORC
	"317":   "garmin", //# 3B-050050 @ HPSC
	"326":   "garmin", //# 3B-050035 @ HVSC
	"10415": "garmin", //# 3B-050030 @ KOWC
	"216":   "feruno", //# 3A-040008 @ KPOC
	"336":   "feruno", //# 3B-050058 @ LINC
	"318":   "feruno", //# 3B-050015 @ LPCC
	"226":   "feruno", //# 3A-040018 @ LPOC
	"217":   "feruno", //# 3A-040013 @ LRSC
	"10410": "garmin", //# 3b-050040 @ LSRC
	"210":   "feruno", //# 3A-040005 @ MAYC
	"330":   "feruno", //# 3B-050047 @ MSMC
	"323":   "garmin", //# 3B-050021 @ NBLC
	"313":   "feruno", //# 3B-050009 @ PEEC
	"329":   "feruno", //# 3B-050056 @ PRPC
	"307":   "garmin", //# 3B-050020 @ RHSC
	"220":   "feruno", //# 3A-040016 @ RKAC
	"211":   "feruno", //# 3A-040003 @ ROLC
	"215":   "feruno", //# 3A-040010 @ SBRC
	"10414": "garmin", //# 3B-050027 @ SCAC
	"10400": "garmin", //# 3B-050024 @ SHFC
	"325":   "garmin", //# 3B-050026 @ SHLC
	"10467": "garmin", //# 3B-050017 @ SLRC
	"327":   "garmin", //# 3B-050049 @ SMTC
	"10403": "hybrid", //# 3B-050014 @ SWNC
	"221":   "feruno", //# 3A-040024 @ TPLC
	"10411": "feruno", //# 3B-050052 @ WAKC
	"10407": "garmin", //# 3B-050031 @ WIGC
	"225":   "feruno", //# 3A-040025 @ WSFC
	"10416": "feruno", //# 3a-040022 @ WTMC

	"357": "feruno", //# MSMC - guess
	"213": "feruno", //# MSMC

	"218": "feruno", //# SHFC
	"309": "feruno", //# WTMC - guess
	"312": "feruno", //# CULC
	"315": "feruno", //# CULC
	"222": "feruno", //# MSMC
	"200": "feruno", //# AMBC
	"303": "hybrid", //# SWNC - odd as it has feruno hardware and garmin firmware

	"205": "feruno", //# CSTC
	"208": "feruno", //# LSRC
	"345": "feruno", //# SCAC
	"212": "feruno", //# WIGC
	"214": "feruno", //# LINC
}

type Pin struct {
	PinNo     int    `xml:"pin_no,attr"`
	Azimuth   string `xml:"azimuth,attr"`
	ChannelId string `xml:"channel_id,attr"`
	Dip       string `xml:"dip,attr"`
	InstCode  string `xml:"inst_code,attr"`
	Reversed  string `xml:"reversed,attr"`
	SeisCode  string `xml:"seis_code,attr"`
	Skip      string `xml:"skip,attr"`
	StreamId  string `xml:"stream_id,attr"`
}

//<cusp installed="2014-12-17 00:00:05" dev_code="CSP" gps="xxxxxx" inst_id="42247" ipaddress="" location_id="20" model="cusp3d" operational="yes" override="no" removed="9999-01-01 11:30:01" sensor_id="42247">

type Cusp struct {
	Installed  string `xml:"installed,attr"`
	AliasId    string `xml:"alias_id,attr,omitempty"`
	DevCode    string `xml:"dev_code,attr"`
	GPS        string `xml:"gps,attr"`
	LocationId string `xml:"location_id,attr"`
	Model      string `xml:"model,attr"`
	Override   string `xml:"override,attr,omitempty"`
	Removed    string `xml:"removed,attr"`
	SensorId   string `xml:"sensor_id,attr"`

	Pins []Pin `xml:"pin,omitempty"`
}

type Site struct {
	SiteId string `xml:"site_id,attr"`
	//Height    float64 `xml:"height,attr"`
	Latitude  float64 `xml:"latitude,attr"`
	Longitude float64 `xml:"longitude,attr"`
	Name      string  `xml:"name,attr"`
	NetworkId string  `xml:"network_id,attr"`

	Cusps []Cusp `xml:"cusp,omitempty"`
}

type StrongMotion struct {
	XMLName xml.Name `xml:"strong_motion"`

	Sites []Site `xml:"site,omitempty"`
}

type Installations []metadb.Installation

func (t Installations) Len() int           { return len(t) }
func (t Installations) Swap(a, b int)      { t[a], t[b] = t[b], t[a] }
func (t Installations) Less(a, b int) bool { return t[a].Start.Before(t[b].Start) }

func main() {

	var base string
	flag.StringVar(&base, "base", "../..", "delta base files")

	var output string
	flag.StringVar(&output, "output", "", "output cusp xml file")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Build a cusp XML file from delta meta & response information\n")
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Usage:\n")
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "  %s [options]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Options:\n")
		fmt.Fprintf(os.Stderr, "\n")
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\n")
	}

	flag.Parse()

	// load delta meta helper
	db, err := metadb.NewMetaDB(base)
	if err != nil {
		fmt.Fprintf(os.Stderr, "problem loading meta db %s: %v\n", base, err)
		os.Exit(1)
	}

	// load station details
	stations, err := db.Stations()
	if err != nil {
		fmt.Fprintf(os.Stderr, "problem loading stations %s: %v\n", base, err)
		os.Exit(1)
	}

	var sites []Site

	// run through each station ....
	for _, station := range stations {

		installations, err := db.Installations(station.Code)
		if err != nil {
			log.Fatalf("problem loading stations %s: %v\n", base, err)
		}

		network, err := db.Network(station.Network)
		if err != nil {
			log.Fatalf("problem loading network %s: %v\n", base, err)
		}
		if network == nil {
			continue
		}

		sort.Sort(Installations(installations))

		var cusps []Cusp
		for _, installation := range installations {

			switch installation.Sensor.Model {
			case "CUSP3C3", "CUSP3D", "CUSP3C", "CUSP3B", "CUSP3A":
				switch installation.Datalogger.Model {
				case "CUSP3C3", "CUSP3D", "CUSP3C", "CUSP3B", "CUSP3A":
					for _, response := range resp.Streams(installation.Datalogger.Model, installation.Sensor.Model) {
						stream, err := db.StationLocationSamplingRateStartStream(
							station.Code,
							installation.Location,
							response.Datalogger.SampleRate,
							installation.Start)
						if err != nil {
							log.Fatalf("problem loading streams %s: %v\n", base, err)
						}
						if stream == nil {
							continue
						}

						if response.Datalogger.SampleRate != 200 {
							continue
						}

						cusps = append(cusps, Cusp{
							Installed: installation.Start.Format("2006-01-02 15:04:05"),
							Removed:   installation.End.Format("2006-01-02 15:04:05"),
							AliasId: func() string {
								if a, ok := aliases[station.Code]; ok {
									return a
								}
								return ""
							}(),

							Override: func() string {
								if _, ok := aliases[station.Code]; ok {
									return "yes"
								}
								return "no"
							}(),
							Model: func() string {
								switch installation.Datalogger.Model {
								case "CUSP3A":
									return "cusp3a"
								case "CUSP3B":
									return "cusp3b"
								case "CUSP3C":
									return "cusp3c"
								case "CUSP3C3":
									return "cusp3c3"
								case "CUSP3D":
									return "cusp3d"
								default:
									return installation.Datalogger.Model
								}
							}(),
							GPS: func() string {
								if g, ok := gps[installation.Sensor.Serial]; ok {
									return g
								}
								return "xxxxxx"
							}(),
							LocationId: installation.Location,
							DevCode:    "CSP",
							SensorId:   installation.Sensor.Serial,
							Pins: func() []Pin {
								var pins []Pin

								lookup := response.Channels(func() bool {
									if installation.Sensor.Azimuth != 0.0 {
										return true
									}
									return stream.Axial
								}())

								for pin, comp := range response.Components {
									if !(pin < len(lookup)) {
										continue
									}
									channel := lookup[pin]

									dip := comp.Dip
									azimuth := installation.Sensor.Azimuth + comp.Azimuth

									// only rotate horizontal components
									if dip == 0.0 {
										if response.Sensor.Reversed {
											azimuth += 180.0
										}
										if response.Datalogger.Reversed {
											azimuth += 180.0
										}
										if stream.Reversed {
											azimuth += 180.0
										}
										// avoid negative zero
										dip = 0.0
									} else {
										if response.Sensor.Reversed {
											dip *= -1.0
										}
										if response.Datalogger.Reversed {
											dip *= -1.0
										}
										if stream.Reversed {
											dip *= -1.0
										}
										azimuth = 0.0
									}

									// bring into positive range
									for azimuth < 0.0 {
										azimuth += 360.0
									}
									for azimuth > 360.0 {
										azimuth -= 360.0
									}

									chan_no := pin
									if loc, err := strconv.Atoi(installation.Location); err == nil {
										chan_no += (loc - 20) * 3
									}

									pins = append(pins, Pin{
										PinNo:     pin,
										ChannelId: channel,
										Azimuth: func() string {
											//azimuth,
											return strconv.FormatFloat(azimuth, 'f', 1, 64)
										}(),
										Dip: func() string {
											//dip,
											return strconv.FormatFloat(dip, 'f', 1, 64)
										}(),
										InstCode: func() string {
											return strings.ToLower(channel[len(channel)-1:])
										}(),
										Reversed: func() string {
											return "no"
										}(),
										SeisCode: func() string {
											switch installation.Sensor.Model {
											case "CUSP3C3", "CUSP3D", "CUSP3C", "CUSP3B", "CUSP3A":
												return "CSA"
											default:
												return installation.Sensor.Model
											}
										}(),
										StreamId: func() string {
											return strings.Join([]string{station.Code,
												func() string {
													return strings.Join([]string{installation.Location, channel}, "-")
												}(),
												func() string {
													if network.External != "" {
														return network.External
													}
													return network.Code

												}()}, "/")
										}(),
										Skip: "no",
									})
								}
								return pins
							}(),
						})
					}
				}
			}
		}

		if !(len(cusps) > 0) {
			continue
		}

		sites = append(sites, Site{
			SiteId: station.Code,
			NetworkId: func() string {
				if network.External != "" {
					return network.External
				}
				return network.Code
			}(),
			Name:      station.Name,
			Latitude:  station.Latitude,
			Longitude: station.Longitude,
			//Height:    station.Elevation,
			Cusps: cusps,
		})

	}

	res, err := xml.MarshalIndent(&StrongMotion{
		Sites: sites,
	}, "", "  ")
	if err != nil {
		log.Fatalf("error: unable to marshal xml: %v", err)
	}
	str := strings.Replace(string(res), "></pin>", " />", -1)
	res = append([]byte(header+warning), append([]byte(str), '\n')...)

	// output as needed ...
	switch {
	case output != "":
		if err := os.MkdirAll(filepath.Dir(output), 0755); err != nil {
			log.Fatalf("error: unable to create directory %s: %v", filepath.Dir(output), err)
		}
		if err := ioutil.WriteFile(output, res, 0644); err != nil {
			log.Fatalf("error: unable to write file %s: %v", output, err)
		}
	default:
		os.Stdout.Write(res)
	}

}
