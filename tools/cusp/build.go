package main

import (
	"encoding/xml"
	"sort"
	"strconv"
	"strings"

	"github.com/GeoNet/delta/internal/metadb"
	"github.com/GeoNet/delta/resp"
)

const header = "<?xml version=\"1.0\" standalone=\"yes\"?>\n"
const warning = "<!-- warning this file is automatically generated -->\n"

type Pin struct {
	PinNo     int    `xml:"pin_no,attr"`
	Azimuth   string `xml:"azimuth,attr"`
	ChannelId string `xml:"channel_id,attr"`
	Dip       string `xml:"dip,attr"`
	InstCode  string `xml:"inst_code,attr"`
	Reversed  string `xml:"reversed,attr"`
	SeisCode  string `xml:"seis_code,attr"`
	Skip      string `xml:"skip,attr"`
	StreamId  string `xml:"stream_id,attr"`
}

type Cusp struct {
	Installed  string `xml:"installed,attr"`
	AliasId    string `xml:"alias_id,attr,omitempty"`
	DevCode    string `xml:"dev_code,attr"`
	GPS        string `xml:"gps,attr"`
	LocationId string `xml:"location_id,attr"`
	Model      string `xml:"model,attr"`
	Override   string `xml:"override,attr,omitempty"`
	Removed    string `xml:"removed,attr"`
	SensorId   string `xml:"sensor_id,attr"`

	Pins []Pin `xml:"pin,omitempty"`
}

type Site struct {
	SiteId string `xml:"site_id,attr"`
	//Height    float64 `xml:"height,attr"`
	Latitude  float64 `xml:"latitude,attr"`
	Longitude float64 `xml:"longitude,attr"`
	Name      string  `xml:"name,attr"`
	NetworkId string  `xml:"network_id,attr"`

	Cusps []Cusp `xml:"cusp,omitempty"`
}

type StrongMotion struct {
	XMLName xml.Name `xml:"strong_motion"`

	Sites []Site `xml:"site,omitempty"`
}

type Installations []metadb.Installation

func (t Installations) Len() int           { return len(t) }
func (t Installations) Swap(a, b int)      { t[a], t[b] = t[b], t[a] }
func (t Installations) Less(a, b int) bool { return t[a].Start.Before(t[b].Start) }

func buildSites(base string) ([]Site, error) {

	// load delta meta helper
	db := metadb.NewMetaDB(base)

	// load station details
	stations, err := db.Stations()
	if err != nil {
		return nil, err
	}

	var sites []Site

	// run through each station ....
	for _, station := range stations {

		installations, err := db.Installations(station.Code)
		if err != nil {
			return nil, err
		}

		network, err := db.Network(station.Network)
		if err != nil {
			return nil, err
		}
		if network == nil {
			continue
		}

		sort.Sort(Installations(installations))

		var cusps []Cusp
		for _, installation := range installations {

			switch installation.Sensor.Model {
			case "CUSP3C3", "CUSP3D", "CUSP3C", "CUSP3B", "CUSP3A":
				switch installation.Datalogger.Model {
				case "CUSP3C3", "CUSP3D", "CUSP3C", "CUSP3B", "CUSP3A":
					for _, response := range resp.Streams(installation.Datalogger.Model, installation.Sensor.Model) {
						stream, err := db.StationLocationSamplingRateStartStream(
							station.Code,
							installation.Location,
							response.Datalogger.SampleRate,
							installation.Start)
						if err != nil {
							return nil, err
						}
						if stream == nil {
							continue
						}

						if response.Datalogger.SampleRate != 200 {
							continue
						}

						cusps = append(cusps, Cusp{
							Installed: installation.Start.Format("2006-01-02 15:04:05"),
							Removed:   installation.End.Format("2006-01-02 15:04:05"),
							AliasId: func() string {
								if a, ok := aliases[station.Code]; ok {
									return a
								}
								return ""
							}(),

							Override: func() string {
								if _, ok := aliases[station.Code]; ok {
									return "yes"
								}
								return "no"
							}(),
							Model: func() string {
								switch installation.Datalogger.Model {
								case "CUSP3A":
									return "cusp3a"
								case "CUSP3B":
									return "cusp3b"
								case "CUSP3C":
									return "cusp3c"
								case "CUSP3C3":
									return "cusp3c3"
								case "CUSP3D":
									return "cusp3d"
								default:
									return installation.Datalogger.Model
								}
							}(),
							GPS: func() string {
								if g, ok := gps[installation.Sensor.Serial]; ok {
									return g
								}
								return "xxxxxx"
							}(),
							LocationId: installation.Location,
							DevCode:    "CSP",
							SensorId:   installation.Sensor.Serial,
							Pins: func() []Pin {
								var pins []Pin

								lookup := response.Channels(func() bool {
									if installation.Sensor.Azimuth != 0.0 {
										return true
									}
									return stream.Axial
								}())

								for pin, comp := range response.Components {
									if !(pin < len(lookup)) {
										continue
									}
									channel := lookup[pin]

									dip := comp.Dip
									azimuth := installation.Sensor.Azimuth + comp.Azimuth

									// only rotate horizontal components
									if dip == 0.0 {
										if response.Sensor.Reversed {
											azimuth += 180.0
										}
										if response.Datalogger.Reversed {
											azimuth += 180.0
										}
										if stream.Reversed {
											azimuth += 180.0
										}
										// avoid negative zero
										dip = 0.0
									} else {
										if response.Sensor.Reversed {
											dip *= -1.0
										}
										if response.Datalogger.Reversed {
											dip *= -1.0
										}
										if stream.Reversed {
											dip *= -1.0
										}
										azimuth = 0.0
									}

									// bring into positive range
									for azimuth < 0.0 {
										azimuth += 360.0
									}
									for azimuth > 360.0 {
										azimuth -= 360.0
									}

									pins = append(pins, Pin{
										PinNo:     pin,
										ChannelId: channel,
										Azimuth: func() string {
											//azimuth,
											return strconv.FormatFloat(azimuth, 'f', 1, 64)
										}(),
										Dip: func() string {
											//dip,
											return strconv.FormatFloat(dip, 'f', 1, 64)
										}(),
										InstCode: func() string {
											return strings.ToLower(channel[len(channel)-1:])
										}(),
										Reversed: func() string {
											return "no"
										}(),
										SeisCode: func() string {
											switch installation.Sensor.Model {
											case "CUSP3C3", "CUSP3D", "CUSP3C", "CUSP3B", "CUSP3A":
												return "CSA"
											default:
												return installation.Sensor.Model
											}
										}(),
										StreamId: func() string {
											return strings.Join([]string{station.Code,
												func() string {
													return strings.Join([]string{installation.Location, channel}, "-")
												}(),
												func() string {
													if network.External != "" {
														return network.External
													}
													return network.Code

												}()}, "/")
										}(),
										Skip: "no",
									})
								}
								return pins
							}(),
						})
					}
				}
			}
		}

		if !(len(cusps) > 0) {
			continue
		}

		sites = append(sites, Site{
			SiteId: station.Code,
			NetworkId: func() string {
				if network.External != "" {
					return network.External
				}
				return network.Code
			}(),
			Name:      station.Name,
			Latitude:  station.Latitude,
			Longitude: station.Longitude,
			//Height:    station.Elevation,
			Cusps: cusps,
		})
	}

	return sites, nil
}

func encodeSites(sites []Site) ([]byte, error) {

	res, err := xml.MarshalIndent(&StrongMotion{
		Sites: sites,
	}, "", "  ")
	if err != nil {
		return nil, err
	}
	str := strings.Replace(string(res), "></pin>", " />", -1)
	res = append([]byte(header+warning), append([]byte(str), '\n')...)

	return res, nil

}
