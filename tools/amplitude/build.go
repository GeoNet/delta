package main

import (
	"encoding/xml"
	"log"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/GeoNet/delta/metadb"
	"github.com/GeoNet/delta/resp"
)

const header = "<?xml version=\"1.0\" standalone=\"yes\"?>\n"
const warning = "<!-- warning this file is automatically generated -->\n"

type Chart struct {
	XMLName xml.Name `xml:"chart"`

	Amplitudes []Amplitude
}

type Amplitude struct {
	XMLName xml.Name `xml:"amplitude"`

	Id      string `xml:"id,attr"`
	Archive int32  `xml:"archive,attr"`
	Daemon  string `xml:"daemon,attr,omitempty"`
	Days    int32  `xml:"days,attr"`
	Delta   int32  `xml:"delta,attr"`
	Dir     string `xml:"dir,attr"`
	File    string `xml:"file,attr"`
	Forever int32  `xml:"forever,attr"`
	Step    int32  `xml:"step,attr"`

	Stations []Station
}

type Station struct {
	XMLName xml.Name `xml:"station"`

	StationId string `xml:"station_id,attr"`
	Name      string `xml:"name,attr"`
	NetworkId string `xml:"network_id,attr"`

	Streams []Stream
}

type Stream struct {
	XMLName xml.Name `xml:"stream"`

	StreamId   string  `xml:"stream_id,attr"`
	ChannelId  string  `xml:"channel_id,attr"`
	Gain       string  `xml:"gain,attr"`
	High       string  `xml:"high,attr,omitempty"`
	LocationId string  `xml:"location_id,attr"`
	Low        string  `xml:"low,attr,omitempty"`
	Q          string  `xml:"q,attr,omitempty"`
	Rate       float64 `xml:"rate,attr"`
	Settling   string  `xml:"settling,attr,omitempty"`
}

type Amplitudes []Amplitude

func (v Amplitudes) Len() int           { return len(v) }
func (v Amplitudes) Swap(a, b int)      { v[a], v[b] = v[b], v[a] }
func (v Amplitudes) Less(a, b int) bool { return v[a].Id < v[b].Id }

type Streams []Stream

func (v Streams) Len() int           { return len(v) }
func (v Streams) Swap(a, b int)      { v[a], v[b] = v[b], v[a] }
func (v Streams) Less(a, b int) bool { return v[a].StreamId < v[b].StreamId }

func buildAmplitudes(cfgs map[string]Config, base, dir string) ([]Amplitude, error) {

	// load delta meta helper
	db := metadb.NewMetaDB(base)

	// load station details
	stations, err := db.Stations()
	if err != nil {
		return nil, err
	}

	now := time.Now()

	var amplitudes []Amplitude

	var keys []string
	for key, _ := range cfgs {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	for _, key := range keys {
		cfg := cfgs[key]

		networks := make(map[string]interface{})
		for _, n := range cfg.Networks {
			networks[n] = true
		}

		xstations := make(map[string]interface{})
		for _, s := range cfg.Stations {
			xstations[s] = true
		}

		loggers := make(map[string]interface{})
		for _, d := range cfg.Loggers {
			loggers[d] = true
		}

		sensors := make(map[string]interface{})
		for _, s := range cfg.Sensors {
			sensors[s] = true
		}

		components := make(map[string]interface{})
		for _, c := range cfg.Components {
			components[c] = true
		}

		// run through each station ....
		for _, station := range stations {
			network, err := db.Network(station.Network)
			if err != nil {
				return nil, err
			}
			if network == nil {
				continue
			}

			if _, ok := networks[network.Code]; !ok {
				if _, ok := xstations[station.Code]; !ok {
					continue
				}
			}

			installations, err := db.Installations(station.Code)
			if err != nil {
				return nil, err
			}

			var streams []Stream

			for _, installation := range installations {
				if installation.End.Before(now) {
					continue
				}

				if _, ok := loggers[installation.Datalogger.Model]; !ok {
					continue
				}
				if _, ok := sensors[installation.Sensor.Model]; !ok {
					continue
				}

				for _, response := range resp.Streams(installation.Datalogger.Model, installation.Sensor.Model) {
					stream, err := db.StationLocationSamplingRateStartStream(
						station.Code,
						installation.Location,
						response.Datalogger.SampleRate,
						installation.Start)
					if err != nil {
						return nil, err
					}
					if stream == nil {
						continue
					}

					r, ok := cfg.Rates[strconv.FormatFloat(response.Datalogger.SampleRate, 'g', -1, 64)]
					if !ok {
						continue
					}

					lookup := response.Channels(stream.Axial)
					for pin, _ := range response.Components {
						if !(pin < len(lookup)) {
							continue
						}
						channel := lookup[pin]

						if _, ok := components[string(channel[len(channel)-1])]; !ok {
							continue
						}

						streams = append(streams, Stream{
							StreamId:   station.Code + "/" + installation.Location + "-" + channel + "/" + network.External,
							LocationId: installation.Location,
							ChannelId:  channel,
							Rate:       response.Datalogger.SampleRate,
							Gain: func() string {
								var gain float64 = 1.0
								if !strings.HasSuffix(channel, "DF") {
									if x, ok := r.Scales[string(channel[len(channel)-1])]; ok {
										gain *= x.(float64)
									} else if r.Scale != 0.0 {
										gain *= r.Scale
									}
								}
								for _, s := range append(response.Sensor.Stages, response.Datalogger.Stages...) {
									if s.StageSet == nil {
										continue
									}
									if s.Gain == 0.0 {
										switch t := s.StageSet.(type) {
										case resp.A2D:
											log.Fatalf("A2D stage should have gain set")
										case resp.PAZ:
											gain *= s.StageSet.(resp.PAZ).Gain(s.Frequency)
										case resp.FIR:
											gain *= s.StageSet.(resp.FIR).Gain
										case resp.Polynomial:
											gain *= s.StageSet.(resp.Polynomial).Gain
										default:
											log.Fatalf("unexpected stage type %T", t)
										}
									} else {
										gain *= s.Gain
									}
								}
								return strconv.FormatFloat(gain, 'f', 5, 64)
							}(),
							High: r.High,
							Low:  r.Low,
							Settling: func() string {
								if channel[0] == 'E' {
									return cfg.Settling
								}
								return ""
							}(),
							Q: func() string {
								if r.Q != "0" {
									return r.Q
								}
								return ""
							}(),
						})
					}
				}
			}

			sort.Sort(Streams(streams))

			if len(streams) > 0 {
				amplitudes = append(amplitudes, Amplitude{
					Id:      key + "-" + strings.ToLower(station.Code),
					Archive: cfg.Archive,
					Days:    cfg.Days,
					Delta:   cfg.Delta,
					Dir:     strings.Replace(filepath.Join(dir, cfg.Dir), "%n", strings.ToLower(network.Code), -1),
					File:    strings.Replace(cfg.File, "%n", strings.ToLower(network.Code), -1),
					Forever: cfg.Forever,
					Step:    cfg.Step,
					Daemon:  cfg.Daemon,
					Stations: []Station{
						Station{
							StationId: station.Code,
							NetworkId: network.External,
							Name:      station.Name,
							Streams:   streams,
						},
					},
				})
			}
		}

		for _, extra := range cfg.Extras {
			amplitudes = append(amplitudes, Amplitude{
				Id:      key + "-" + strings.ToLower(extra.StationId),
				Archive: cfg.Archive,
				Days:    cfg.Days,
				Delta:   cfg.Delta,
				Dir:     filepath.Join(dir, cfg.Dir),
				File:    cfg.File,
				Forever: cfg.Forever,
				Step:    cfg.Step,
				Daemon:  cfg.Daemon,
				Stations: []Station{
					Station{
						StationId: extra.StationId,
						NetworkId: extra.NetworkId,
						Name:      extra.Name,
						Streams: func() []Stream {
							var s []Stream
							for l, loc := range extra.Locations {
								for c, cha := range loc {
									s = append(s, Stream{
										StreamId:   extra.StationId + "/" + l + "-" + c + "/" + extra.NetworkId,
										LocationId: l,
										ChannelId:  c,
										Rate:       cha.Rate,
										Gain:       strconv.FormatFloat(cha.Gain, 'f', 5, 64),
										High:       cha.High,
										Low:        cha.Low,
										Q:          cha.Q,
									})
								}
							}
							sort.Sort(Streams(s))
							return s
						}(),
					},
				},
			})
		}

	}

	sort.Sort(Amplitudes(amplitudes))

	return amplitudes, nil
}

func encodeAmplitudes(amplitudes []Amplitude) ([]byte, error) {

	res, err := xml.MarshalIndent(&Chart{
		Amplitudes: amplitudes,
	}, "", "  ")
	if err != nil {
		return nil, err
	}
	str := strings.Replace(string(res), "></stream>", " />", -1)
	res = append([]byte(header+warning), append([]byte(str), '\n')...)

	return res, nil
}
