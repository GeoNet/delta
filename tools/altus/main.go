package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"sync"

	"github.com/GeoNet/delta/helper/metadb"
	"github.com/GeoNet/delta/resp"
)

const header = "<?xml version=\"1.0\" standalone=\"yes\"?>\n"
const warning = "<!-- warning this file is automatically generated -->\n"

var aliases = map[string]string{
	"DECF": "RR#1",
	"CSBF": "RR#2",
	"BCOF": "FDLS",
	"TLED": "RR2",
	"COLD": "RR3",
	"GODS": "D12C",
	"DCZ":  "DCSM",
	"SECF": "SECS",
	"JCWJ": "JACS",
	"KVSD": "RR5",
	"PARS": "D11C",
}

type Pin struct {
	PinNo    int    `xml:"pin_no,attr"`
	Azimuth  string `xml:"azimuth,attr"`
	ChanNo   string `xml:"chan_no,attr,omitempty"`
	Dip      string `xml:"dip,attr"`
	InstCode string `xml:"inst_code,attr"`
	Reversed string `xml:"reversed,attr"`
	SeisCode string `xml:"seis_code,attr"`
	StreamId string `xml:"stream_id,attr"`
}

type Altus struct {
	Installed string `xml:"installed,attr"`
	Alias     string `xml:"alias_id,attr,omitempty"`
	DevCode   string `xml:"dev_code,attr"`
	InstId    string `xml:"inst_id,attr"`
	Override  string `xml:"override,attr,omitempty"`
	Removed   string `xml:"removed,attr"`

	Pins []Pin `xml:"pin,omitempty"`
}

type Site struct {
	SiteId    string  `xml:"site_id,attr"`
	Height    float64 `xml:"height,attr"`
	Latitude  float64 `xml:"latitude,attr"`
	Longitude float64 `xml:"longitude,attr"`
	Name      string  `xml:"name,attr"`
	NetworkId string  `xml:"network_id,attr"`

	Altuses []Altus `xml:"altus,omitempty"`
}

type StrongMotion struct {
	XMLName xml.Name `xml:"strong_motion"`

	Sites []Site `xml:"site,omitempty"`
}

type Installations []metadb.Installation

func (t Installations) Len() int           { return len(t) }
func (t Installations) Swap(a, b int)      { t[a], t[b] = t[b], t[a] }
func (t Installations) Less(a, b int) bool { return t[a].Start.Before(t[b].Start) }

func main() {

	var base string
	flag.StringVar(&base, "base", "../..", "delta base files")

	var output string
	flag.StringVar(&output, "output", "", "output altus xml file")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Build an altus XML file from delta meta & response information\n")
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Usage:\n")
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "  %s [options]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Options:\n")
		fmt.Fprintf(os.Stderr, "\n")
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\n")
	}

	flag.Parse()

	// load delta meta helper
	db, err := metadb.NewMetaDB(base)
	if err != nil {
		fmt.Fprintf(os.Stderr, "problem loading meta db %s: %v\n", base, err)
		os.Exit(1)
	}

	// load station details
	stations, err := db.Stations()
	if err != nil {
		fmt.Fprintf(os.Stderr, "problem loading stations %s: %v\n", base, err)
		os.Exit(1)
	}

	var sites []Site

	// run through each station ....
	for _, station := range stations {

		installations, err := db.Installations(station.Code)
		if err != nil {
			log.Fatalf("problem loading stations %s: %v\n", base, err)
		}

		network, err := db.Network(station.Network)
		if err != nil {
			log.Fatalf("problem loading network %s: %v\n", base, err)
		}
		if network == nil {
			continue
		}

		sort.Sort(Installations(installations))

		var static sync.Once
		var altuses []Altus

		for _, installation := range installations {

			switch installation.Datalogger.Model {
			case "Q330/3", "Q330/6", "Q330HR/6", "Q330S/3", "Q330S/6":
				switch installation.Sensor.Model {
				case "FBA-ES-T", "FBA-ES-T-ISO":
					if a, ok := slates[station.Code]; ok {
						static.Do(func() {
							altuses = append(altuses, a...)
						})
					}
				}
				continue
			}

			switch installation.Sensor.Model {
			case "FBA-ES-T-BASALT", "FBA-ES-T-DECK", "FBA-23-DECK", "FBA-ES-T", "FBA-ES-T-ISO", "Kinemetrics SBEPI", "SDP":
				switch installation.Datalogger.Model {
				case "OBSIDIAN", "K2", "ETNA", "BASALT", "BASALT 8X DATALOGGER":
					for _, response := range resp.Streams(installation.Datalogger.Model, installation.Sensor.Model) {
						stream, err := db.StationLocationSamplingRateStartStream(
							station.Code,
							installation.Location,
							response.Datalogger.SampleRate,
							installation.Start)
						if err != nil {
							log.Fatalf("problem loading streams %s: %v\n", base, err)
						}
						if stream == nil {
							continue
						}

						if response.Datalogger.SampleRate != 200 {
							continue
						}

						altuses = append(altuses, Altus{
							Installed: installation.Start.Format("2006/01/02,15:04:05"),
							Removed:   installation.End.Format("2006/01/02,15:04:05"),
							Override: func() string {
								if _, ok := aliases[station.Code]; ok {
									return "yes"
								}
								switch installation.Datalogger.Model {
								case "ETNA":
									return "no"
								default:
									return ""
								}
							}(),
							Alias: func() string {
								if a, ok := aliases[station.Code]; ok {
									return a
								}
								return ""
							}(),
							DevCode: func() string {
								switch installation.Datalogger.Model {
								case "K2":
									return "K2 "
								case "ETNA":
									return "ETN"
								case "BASALT":
									return "BAS"
								case "BASALT 8X DATALOGGER":
									return "BAS"
								case "OBSIDIAN":
									return "OBS"
								default:
									return installation.Datalogger.Model
								}
							}(),
							InstId: func() string {
								switch installation.Datalogger.Model {
								case "BASALT 8X DATALOGGER":
									return installation.Datalogger.Serial
								default:
									return installation.Sensor.Serial
								}
							}(),
							Pins: func() []Pin {
								var pins []Pin

								lookup := response.Channels(func() bool {
									if installation.Sensor.Azimuth != 0.0 {
										return true
									}
									return stream.Axial
								}())

								for pin, comp := range response.Components {
									if !(pin < len(lookup)) {
										continue
									}
									channel := lookup[pin]

									dip := comp.Dip
									azimuth := installation.Sensor.Azimuth + comp.Azimuth
									reversed := func() bool {
										switch installation.Sensor.Model {
										case "FBA-23-DECK":
											return true
										default:
											return false
										}
									}()

									// only rotate horizontal components
									if dip == 0.0 {
										if reversed {
											azimuth += 180.0
										}
										if response.Sensor.Reversed {
											azimuth += 180.0
										}
										if response.Datalogger.Reversed {
											azimuth += 180.0
										}
										if stream.Reversed {
											azimuth += 180.0
										}
										// avoid negative zero
										dip = 0.0
									} else {
										if reversed {
											dip *= -1.0
										}
										if response.Sensor.Reversed {
											dip *= -1.0
										}
										if response.Datalogger.Reversed {
											dip *= -1.0
										}
										if stream.Reversed {
											dip *= -1.0
										}
										azimuth = 0.0
									}

									// bring into positive range
									for azimuth < 0.0 {
										azimuth += 360.0
									}
									for azimuth > 360.0 {
										azimuth -= 360.0
									}

									chan_no := pin
									if loc, err := strconv.Atoi(installation.Location); err == nil {
										chan_no += (loc - 20) * 3
									}

									pins = append(pins, Pin{
										PinNo: pin,
										ChanNo: func() string {
											switch installation.Datalogger.Model {
											case "BASALT 8X DATALOGGER":
												if chan_no > 2 {
													return strconv.Itoa(chan_no)
												}
												return ""
											default:
												return ""
											}
										}(),
										Azimuth: func() string {
											//azimuth,
											return strconv.FormatFloat(azimuth, 'f', 1, 64)
										}(),
										Dip: func() string {
											//dip,
											return strconv.FormatFloat(dip, 'f', 1, 64)
										}(),
										InstCode: func() string {
											return strings.ToLower(channel[len(channel)-1:])
										}(),
										Reversed: func() string {
											switch installation.Sensor.Model {
											case "FBA-23-DECK":
												return "yes"
											default:
												return "no"
											}
										}(),
										SeisCode: func() string {
											switch installation.Sensor.Model {
											case "Kinemetrics SBEPI":
												return "EPI"
											case "FBA-ES-T-OBSIDIAN":
												return "OBS"
											case "FBA-ES-T-BASALT":
												return "BAS"
											case "FBA-ES-T-DECK":
												return "EP2"
											case "FBA-23-DECK":
												return "FB2"
											case "FBA-ES-T":
												return "EPI"
											case "SDP":
												return "SDP"
											default:
												return installation.Sensor.Model
											}
										}(),
										StreamId: func() string {
											return strings.Join([]string{station.Code,
												func() string {
													return strings.Join([]string{installation.Location, channel}, "-")
												}(),
												func() string {
													if network.External != "" {
														return network.External
													}
													return network.Code

												}()}, "/")
										}(),
									})
								}
								return pins
							}(),
						})
					}
				}
			}
		}

		if !(len(altuses) > 0) {
			continue
		}

		sites = append(sites, Site{
			SiteId: station.Code,
			NetworkId: func() string {
				if network.External != "" {
					return network.External
				}
				return network.Code
			}(),
			Name:      station.Name,
			Latitude:  station.Latitude,
			Longitude: station.Longitude,
			Height:    station.Elevation,
			Altuses:   altuses,
		})

	}

	res, err := xml.MarshalIndent(&StrongMotion{
		Sites: sites,
	}, "", "  ")
	if err != nil {
		log.Fatalf("error: unable to marshal xml: %v", err)
	}
	str := strings.Replace(string(res), "></pin>", " />", -1)
	res = append([]byte(header+warning), append([]byte(str), '\n')...)

	// output as needed ...
	switch {
	case output != "":
		if err := os.MkdirAll(filepath.Dir(output), 0755); err != nil {
			log.Fatalf("error: unable to create directory %s: %v", filepath.Dir(output), err)
		}
		if err := ioutil.WriteFile(output, res, 0644); err != nil {
			log.Fatalf("error: unable to write file %s: %v", output, err)
		}
	default:
		os.Stdout.Write(res)
	}

}
