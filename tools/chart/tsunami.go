package main

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v2"

	"github.com/GeoNet/delta/metadb"
)

const header = "<?xml version=\"1.0\" standalone=\"yes\"?>\n"
const warning = "<!-- warning this file is automatically generated -->\n"

type Config struct {
	Filename string                `yaml:"filename"`
	Pages    map[string]ConfigPage `yaml:"pages"`
}

type ConfigPage struct {
	Base      string            `yaml:"base"`
	RRD       string            `yaml:"rrd"`
	Networks  []string          `yaml:"networks"`
	Location  string            `yaml:"location"`
	Override  map[string]string `yaml:"override"`
	Bands     []string          `yaml:"bands"`
	Orients   []string          `yaml:"orients"`
	Sensors   []string          `yaml:"sensors"`
	Detide    int32             `yaml:"detide"`
	Reference int32             `yaml:"reference"`
}

func (c ConfigPage) GetLocation(sta string) string {
	if loc, ok := c.Override[sta]; ok {
		return loc
	}
	return c.Location
}

func (c ConfigPage) Channels() []string {
	var chans []string
	for _, b := range c.Bands {
		for _, s := range c.Sensors {
			for _, o := range c.Orients {
				chans = append(chans, b+s+o)
			}
		}
	}

	sort.Strings(chans)

	return chans
}

type Chart struct {
	XMLName xml.Name `xml:"chart"`

	Pages []Page
}

type Page struct {
	XMLName xml.Name `xml:"page"`

	Id    string `xml:"id,attr"`
	Png   string `xml:"png,attr"`
	Plots []Plot `xml:"plot"`
}

type Plot struct {
	XMLName xml.Name `xml:"plot"`

	Id      string  `xml:"id,attr"`
	Clip    int32   `xml:"clip,attr"`
	Length  string  `xml:"length,attr"`
	Max     float64 `xml:"max,attr"`
	Min     float64 `xml:"min,attr"`
	Overlap int32   `xml:"overlap,attr"`
	Width   int32   `xml:"width,attr"`

	Border    Border
	Copyright Copyright
	Date      Date
	Label     Label
	Streams   []Stream
	Title     Title
	XGrid     XGrid
	XLabel    XLabel
	XTick     XTick
	YLabel    YLabel
}

type Border struct {
	XMLName xml.Name `xml:"border"`

	Bg       string `xml:"bg,attr"`
	Colour   string `xml:"colour,attr"`
	Gradient string `xml:"gradient,attr"`
}

type Copyright struct {
	XMLName xml.Name `xml:"copyright"`

	Font string `xml:"font,attr"`
}

type Date struct {
	XMLName xml.Name `xml:"date"`

	Font string `xml:"font,attr"`
}

type Label struct {
	XMLName xml.Name `xml:"label"`

	Colour string `xml:"colour,attr"`
	Font   string `xml:"font,attr"`
	String string `xml:"string,attr"`
}

type Stream struct {
	XMLName xml.Name `xml:"stream"`

	Auto   string `xml:"auto,attr"`
	Colour string `xml:"colour,attr"`
	Format string `xml:"format,attr"`
	Rrd    string `xml:"rrd,attr"`
	Style  string `xml:"style,attr"`

	Name     Name
	Scalebar *Scalebar `xml:",omitempty"`
	Tag      Tag

	lag float64
}

type Title struct {
	XMLName xml.Name `xml:"title"`

	Colour string `xml:"colour,attr"`
	Font   string `xml:"font,attr"`
}

type XGrid struct {
	XMLName xml.Name `xml:"xgrid"`

	Colour string `xml:"colour,attr"`
	Step   string `xml:"step,attr"`
}

type XLabel struct {
	XMLName xml.Name `xml:"xlabel"`

	Colour string `xml:"colour,attr"`
	Font   string `xml:"font,attr"`
	String string `xml:"string,attr"`
}

type XTick struct {
	XMLName xml.Name `xml:"xtick"`

	Colour  string `xml:"colour,attr"`
	Factor  string `xml:"factor,attr"`
	Font    string `xml:"font,attr"`
	Step    string `xml:"step,attr"`
	YOffset int32  `xml:"yoffset,attr"`
}

type YLabel struct {
	XMLName xml.Name `xml:"ylabel"`

	Colour string `xml:"colour,attr"`
	Font   string `xml:"font,attr"`
	String string `xml:"string,attr"`
}

type Name struct {
	XMLName xml.Name `xml:"name"`

	Box     string `xml:"box,attr"`
	Colour  string `xml:"colour,attr"`
	Font    string `xml:"font,attr"`
	Pad     int32  `xml:"pad,attr"`
	String  string `xml:"string,attr"`
	XOffset int32  `xml:"xoffset,attr"`
	YOffset int32  `xml:"yoffset,attr,omitempty"`
}

type Tag struct {
	XMLName xml.Name `xml:"tag"`

	Aligned string `xml:"aligned,attr"`
	Colour  string `xml:"colour,attr"`
	Font    string `xml:"font,attr"`
	Rotated string `xml:"rotated,attr"`
	String  string `xml:"string,attr"`
	XOffset int32  `xml:"xoffset,attr"`
	YOffset int32  `xml:"yoffset,attr,omitempty"`
}

type Pin struct {
	PinNo    int    `xml:"pin_no,attr"`
	Azimuth  string `xml:"azimuth,attr"`
	ChanNo   string `xml:"chan_no,attr,omitempty"`
	Dip      string `xml:"dip,attr"`
	InstCode string `xml:"inst_code,attr"`
	Reversed string `xml:"reversed,attr"`
	SeisCode string `xml:"seis_code,attr"`
	StreamId string `xml:"stream_id,attr"`
}

type Altus struct {
	Installed string `xml:"installed,attr"`
	Alias     string `xml:"alias_id,attr,omitempty"`
	DevCode   string `xml:"dev_code,attr"`
	InstId    string `xml:"inst_id,attr"`
	Override  string `xml:"override,attr,omitempty"`
	Removed   string `xml:"removed,attr"`

	Pins []Pin `xml:"pin,omitempty"`
}

type Site struct {
	SiteId    string  `xml:"site_id,attr"`
	Height    float64 `xml:"height,attr"`
	Latitude  float64 `xml:"latitude,attr"`
	Longitude float64 `xml:"longitude,attr"`
	Name      string  `xml:"name,attr"`
	NetworkId string  `xml:"network_id,attr"`

	Altuses []Altus `xml:"altus,omitempty"`
}

type Scalebar struct {
	XMLName xml.Name `xml:"scalebar"`

	Length  int32 `xml:"length,attr"`
	Stroke  int32 `xml:"stroke,attr"`
	Width   int32 `xml:"width,attr"`
	YOffset int32 `xml:"yoffset,attr"`

	Scale Scale
}

type Scale struct {
	XMLName xml.Name `xml:"scale"`

	String string `xml:"string,attr"`
}

type Installations []metadb.Installation

func (t Installations) Len() int           { return len(t) }
func (t Installations) Swap(a, b int)      { t[a], t[b] = t[b], t[a] }
func (t Installations) Less(a, b int) bool { return t[a].Start.Before(t[b].Start) }

type Streams []Stream

func (s Streams) Len() int           { return len(s) }
func (s Streams) Swap(a, b int)      { s[a], s[b] = s[b], s[a] }
func (s Streams) Less(a, b int) bool { return s[a].lag > s[b].lag }

func loadConfig(config string) (map[string]Config, error) {
	var cfgs map[string]Config

	b, err := ioutil.ReadFile(config)
	if err != nil {
		return nil, err
	}

	if err := yaml.Unmarshal(b, &cfgs); err != nil {
		return nil, err
	}

	return cfgs, nil
}

func buildPages(cfgs map[string]Config, base string) ([]Page, error) {

	// load delta meta helper
	db := metadb.NewMetaDB(base)

	var pages []Page
	for _, cfg := range cfgs {
		var keys []string
		for k, _ := range cfg.Pages {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			v := cfg.Pages[k]

			chans := make(map[string]interface{})
			for _, c := range v.Channels() {
				chans[c] = true
			}

			var plots []Plot

			for _, net := range v.Networks {
				var list []Stream

				stns, err := db.NetworkStation(net)
				if err != nil {
					return nil, err
				}

				for _, s := range stns {
					chas, err := db.Channels(s.Code)
					if err != nil {
						return nil, err
					}

					for _, c := range chas {
						if time.Now().After(c.End) {
							continue
						}

						if _, ok := chans[c.Code]; !ok {
							continue
						}
						if v.GetLocation(s.Code) != c.Location {
							continue
						}

						constituents, err := db.GaugeConstituents(s.Code)
						if err != nil {
							continue
						}
						var lag float64
						for _, t := range constituents {
							switch t.Name {
							case "M2":
								lag = t.Lag
							}
						}

						list = append(list, Stream{
							Auto:   "no",
							Colour: "#000000a0",
							Format: "amplitude",
							Rrd: fmt.Sprintf("/work/chart/amplitude/tsunami/%s/%s.rrd", func() string {
								return strings.ToLower(strings.Join([]string{s.Code, net}, "."))
							}(), func() string {
								return strings.ToLower(strings.Join([]string{s.Code, strings.Join([]string{c.Location, c.Code}, "-"), net}, "."))
							}()),
							Style: "gauge",
							Name: Name{
								Box:     "#ffffffd0",
								Colour:  "#006400",
								Font:    "LiberationSans Bold Italic 11",
								Pad:     2,
								String:  s.Name,
								XOffset: 10,
								YOffset: func() int32 {
									if v.Detide != 0 {
										return -15
									}
									return 0
								}(),
							},
							Tag: Tag{
								Aligned: "first",
								Colour:  "#006400",
								Font:    "LiberationSans Narrow Bold 8",
								Rotated: "yes",
								String:  s.Code,
								XOffset: 5,
							},
							lag: lag,
						})
					}
				}

				sort.Sort(Streams(list))

				if len(list) > 0 {
					reference := func() int {
						switch {
						case v.Reference < 0:
							return (len(list) + int(v.Reference)) % len(list)
						default:
							return int(v.Reference) % len(list)
						}
					}()
					list[reference].Scalebar = &Scalebar{
						Length:  1000,
						Stroke:  2,
						Width:   5,
						YOffset: 0,
						Scale: Scale{
							String: "one metre",
						},
					}
				}

				plots = append(plots, Plot{
					Id: func() string {
						if v.Detide != 0 {
							return "detide"
						}
						return "gauge"
					}(),
					Clip:    100,
					Length:  "36 hours",
					Max:     1500,
					Min:     -1500,
					Overlap: 25,
					Width:   795,
					Border: Border{
						Bg:       "#90EE90",
						Colour:   "#ffffff",
						Gradient: "#ffffffa0",
					},
					Copyright: Copyright{
						Font: "LiberationSans Narrow 9",
					},
					Date: Date{
						Font: "LiberationSans Narrow Bold 14",
					},
					Label: Label{
						Colour: "#006400",
						Font:   "LiberationSans Bold Italic 14",
						String: "New Zealand Tsunami Gauge Network",
					},
					Streams: list,
					Title: Title{
						Colour: "#006400",
						Font:   "LiberationSans Bold Italic 14",
					},
					XGrid: XGrid{
						Colour: "#ffffff70",
						Step:   "21600",
					},
					XLabel: XLabel{
						Colour: "#006400",
						Font:   "LiberationSans Italic Bold 12",
						String: "Hours before current timestamp",
					},
					XTick: XTick{
						Colour:  "#006400",
						Factor:  "3600",
						Font:    "LiberationSans Bold 12",
						Step:    "21600",
						YOffset: 5,
					},
					YLabel: YLabel{
						Colour: "#006400",
						Font:   "LiberationSans Italic Bold 12",
						String: "Relative sea level",
					},
				})
				pages = append(pages, Page{
					Id: func() string {
						if v.Detide != 0 {
							return "tsunami-detide-detide-" + strings.ToLower(net)
						}
						return "tsunami-gauge-gauge-" + strings.ToLower(net)
					}(),
					Png: func() string {
						if v.Detide != 0 {
							return filepath.Join(v.Base, "/tsunami/plots/latest/detide.png")
						}
						return filepath.Join(v.Base, "/tsunami/plots/latest/gauge.png")
					}(),
					Plots: plots,
				})
			}
		}
	}

	return pages, nil
}

func encodePages(pages []Page) ([]byte, error) {

	res, err := xml.MarshalIndent(&Chart{
		Pages: pages,
	}, "", "  ")
	if err != nil {
		return nil, err
	}
	str := string(res)
	for _, t := range []string{"border", "copyright", "date", "label", "name", "tag", "title", "xlabel", "ylabel", "xgrid", "xtick", "scale"} {
		str = strings.Replace(str, "></"+t+">", " />", -1)
	}
	res = append([]byte(header+warning), append([]byte(str), '\n')...)

	return res, nil
}
